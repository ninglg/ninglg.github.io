<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Light Up The World</title><link rel="preload" href="/_next/static/css/f746a819331ac28f.css" as="style"/><link rel="preload" href="/_next/static/css/67a8467bbb0bf2f3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f746a819331ac28f.css" data-n-g=""/><link rel="stylesheet" href="/_next/static/css/67a8467bbb0bf2f3.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-0d0518cf5dc92fa8.js" defer=""></script><script src="/_next/static/chunks/framework-3b42cd6c159eee45.js" defer=""></script><script src="/_next/static/chunks/main-3a6cdb4de470543c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b1567c0152ea5cdf.js" defer=""></script><script src="/_next/static/chunks/8-69a6136648adcc6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-71ee397017ad762c.js" defer=""></script><script src="/_next/static/rQGl2E3ObLYgPNk8QlWuc/_buildManifest.js" defer=""></script><script src="/_next/static/rQGl2E3ObLYgPNk8QlWuc/_ssgManifest.js" defer=""></script></head><body class="antialiased"><div id="__next"><div class="Post_container__ictJu"><nav class="Nav_nav__o8sSc"><div class="Nav_navContainer__KuO9f"><a class="Nav_navLogo__aczrM" href="/">Light Ning</a><div class="Nav_navLinks__sb_3K"><a class="Nav_navLink__z2PDT " href="/">首页</a><a class="Nav_navLink__z2PDT " href="/about">关于</a></div></div></nav><main class="Post_main__X4Tic"><article class="Post_post__1KH4p"><h1 class="Post_title__pen_7">Redis的内存使用量分析</h1><time class="Post_date__YGL_Q">2018-01-17</time><div class="Post_postTags__df1Jm"><span class="Post_postTag__j37er">Redis</span></div><div class="Post_content__aWM2C"><p>在大部分场景下，Redis都作为纯内存的NoSQL系统运行。所以，有必要了解其内存使用的组成和相应的分析方法。</p>
<h2>内存使用量限制及数据淘汰策略</h2>
<h3>内存使用量限制</h3>
<p>Redis的配置项maxmemory默认没有设定值，可以通过此项配置来限制单机最大使用的内存量。在实际使用中，如果超过了此值，则需要根据maxmemory-policy中设定的策略进行数据淘汰。maxmemory-policy的默认值是noeviction。</p>
<h3>淘汰策略</h3>
<p>规则名称 | 规则说明
--- | ---
volatile-lru | 使用近似的LRU算法删除一个键（只对设置了生存时间的键）
allkeys-lru | 使用近似的LRU算法删除一个键
volatile-lfu | 使用近似的LFU算法删除一个键（只对设置了生存时间的键）
allkeys-lfu | 使用近似的LFU算法删除一个键
volatile-random | 随机删除一个键（只对设置了生存时间的键）
allkeys-random | 随机删除一个键
volatile-ttl | 删除生存时间最近的一个键
noeviction | 不删除键，只返回错误</p>
<p>LRU算法（Least Recently Used），最近最少使用算法。即默认删除最近最少使用的键。但是要注意：Redis中并不会准确的删除所有键中最近最少使用的键，而是随机抽取5个键，删除这5个键中最近最少使用的键。5这个数字也是可以设置的，对应位置是配置文件中的maxmemory-samples。</p>
<h2>内存使用量分析</h2>
<p>可以使用以下命令来查看Redis的内存使用情况：</p>
<blockquote>
<p>info</p>
</blockquote>
<p>统计大key并处理</p>
<blockquote>
<p>redis-cli --bigkeys 命令可以统计bigkey的分布
为了解决删除大键造成redis阻塞的问题， redis 4.0 引入了lazyfree的机制，它可以将删除键或数据库的操作放在后台线程里执行， 从而尽可能地避免服务器阻塞
如果set/zset元素个数较少（少于64个）或者是String类型，也会在主线程中直接删除而不走异步模式</p>
</blockquote>
<p>info命令输出的数据可分为10个类别，分别是：</p>
<pre><code>server
clients
memory
persistence
stats
replication
cpu
commandstats
cluster
keyspace
</code></pre>
<p>或直接用：</p>
<blockquote>
<p>info memory</p>
</blockquote>
<p>条目  |  说明
--- | ---
used_memory | 分配器分配的内存量，也就是实际存储数据的内存总量
used_memory_human | 以可读格式返回 Redis 使用的内存总量
used_memory_rss | 从操作系统的角度，Redis进程占用的总物理内存
used_memory_peak | 内存分配器分配的最大内存，代表used_memory的历史峰值
used_memory_lua | Lua引擎所消耗的内存
maxmemory_policy | noeviction（达到最大内存占用后的清理策略）
mem_fragmentation_ratio | used_memory_rss /used_memory比值，表示内存碎片率
mem_allocator | libc（Redis 所使用的内存分配器）</p>
<p>计算公式如下：</p>
<blockquote>
<p>used_memory = 自身内存+对象内存+缓冲内存+lua内存
used_rss = used_memory + 内存碎片</p>
</blockquote>
<p><strong>内存碎片率保持在1.0至1.5之间是最理想的状态。</strong> 假若碎片率超过了1.5，有效解决手段就是重启Redis服务器，释放内存回到操作系统。反之，若碎片率为0.9，说明物理内存已不够用，应增添硬件，或修改Redis最大内存限制maxmemory。
<strong>最大内存限制maxmemory的设置非常重要。</strong> 如果不设置maxmemory，Redis一直会为其分配内存，直至耗尽所有物理内存，直到操作系统进行虚拟内存交换。</p>
<h2>内存集群</h2>
<ol>
<li>
<p>客户端分片
通过业务代码自己实现路由，性能较好但维护成本高。</p>
</li>
<li>
<p>代理分片
使用类似Twemproxy、Codis等中间件实现。
Codis在Twemproxy基础上优化并实现了预分片来达到Auto Rebalance。</p>
</li>
<li>
<p>RedisCluster
官方集群解决方案。方案较重，使用的案例较少。</p>
</li>
</ol>
</div></article><div class="Post_postNavigation__TSrfz"><a class="Post_navLink__iyGDb" href="/posts/redis-cluster-solution">← <!-- -->Redis集群方案介绍</a><a class="Post_navLink__iyGDb Post_nextLink__THXHn" href="/posts/bloomfilter">BloomFilter（布隆过滤器）介绍<!-- --> →</a></div></main><footer class="footer_footer__mqdak"><p>© <!-- -->2025<!-- --> <!-- -->Light Ning<!-- --> All rights reserved.</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"summary":null,"tags":["Redis"],"id":"redis-memory-usage-analysis","contentHtml":"\u003cp\u003e在大部分场景下，Redis都作为纯内存的NoSQL系统运行。所以，有必要了解其内存使用的组成和相应的分析方法。\u003c/p\u003e\n\u003ch2\u003e内存使用量限制及数据淘汰策略\u003c/h2\u003e\n\u003ch3\u003e内存使用量限制\u003c/h3\u003e\n\u003cp\u003eRedis的配置项maxmemory默认没有设定值，可以通过此项配置来限制单机最大使用的内存量。在实际使用中，如果超过了此值，则需要根据maxmemory-policy中设定的策略进行数据淘汰。maxmemory-policy的默认值是noeviction。\u003c/p\u003e\n\u003ch3\u003e淘汰策略\u003c/h3\u003e\n\u003cp\u003e规则名称 | 规则说明\n--- | ---\nvolatile-lru | 使用近似的LRU算法删除一个键（只对设置了生存时间的键）\nallkeys-lru | 使用近似的LRU算法删除一个键\nvolatile-lfu | 使用近似的LFU算法删除一个键（只对设置了生存时间的键）\nallkeys-lfu | 使用近似的LFU算法删除一个键\nvolatile-random | 随机删除一个键（只对设置了生存时间的键）\nallkeys-random | 随机删除一个键\nvolatile-ttl | 删除生存时间最近的一个键\nnoeviction | 不删除键，只返回错误\u003c/p\u003e\n\u003cp\u003eLRU算法（Least Recently Used），最近最少使用算法。即默认删除最近最少使用的键。但是要注意：Redis中并不会准确的删除所有键中最近最少使用的键，而是随机抽取5个键，删除这5个键中最近最少使用的键。5这个数字也是可以设置的，对应位置是配置文件中的maxmemory-samples。\u003c/p\u003e\n\u003ch2\u003e内存使用量分析\u003c/h2\u003e\n\u003cp\u003e可以使用以下命令来查看Redis的内存使用情况：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003einfo\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e统计大key并处理\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eredis-cli --bigkeys 命令可以统计bigkey的分布\n为了解决删除大键造成redis阻塞的问题， redis 4.0 引入了lazyfree的机制，它可以将删除键或数据库的操作放在后台线程里执行， 从而尽可能地避免服务器阻塞\n如果set/zset元素个数较少（少于64个）或者是String类型，也会在主线程中直接删除而不走异步模式\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003einfo命令输出的数据可分为10个类别，分别是：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eserver\nclients\nmemory\npersistence\nstats\nreplication\ncpu\ncommandstats\ncluster\nkeyspace\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e或直接用：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003einfo memory\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e条目  |  说明\n--- | ---\nused_memory | 分配器分配的内存量，也就是实际存储数据的内存总量\nused_memory_human | 以可读格式返回 Redis 使用的内存总量\nused_memory_rss | 从操作系统的角度，Redis进程占用的总物理内存\nused_memory_peak | 内存分配器分配的最大内存，代表used_memory的历史峰值\nused_memory_lua | Lua引擎所消耗的内存\nmaxmemory_policy | noeviction（达到最大内存占用后的清理策略）\nmem_fragmentation_ratio | used_memory_rss /used_memory比值，表示内存碎片率\nmem_allocator | libc（Redis 所使用的内存分配器）\u003c/p\u003e\n\u003cp\u003e计算公式如下：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eused_memory = 自身内存+对象内存+缓冲内存+lua内存\nused_rss = used_memory + 内存碎片\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e内存碎片率保持在1.0至1.5之间是最理想的状态。\u003c/strong\u003e 假若碎片率超过了1.5，有效解决手段就是重启Redis服务器，释放内存回到操作系统。反之，若碎片率为0.9，说明物理内存已不够用，应增添硬件，或修改Redis最大内存限制maxmemory。\n\u003cstrong\u003e最大内存限制maxmemory的设置非常重要。\u003c/strong\u003e 如果不设置maxmemory，Redis一直会为其分配内存，直至耗尽所有物理内存，直到操作系统进行虚拟内存交换。\u003c/p\u003e\n\u003ch2\u003e内存集群\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e客户端分片\n通过业务代码自己实现路由，性能较好但维护成本高。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e代理分片\n使用类似Twemproxy、Codis等中间件实现。\nCodis在Twemproxy基础上优化并实现了预分片来达到Auto Rebalance。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRedisCluster\n官方集群解决方案。方案较重，使用的案例较少。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n","date":"2018-01-17T10:06:19.000Z","title":"Redis的内存使用量分析","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["Redis"],"id":"redis-cluster-solution","title":"Redis集群方案介绍","date":"2018-01-18T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false},"nextPost":{"summary":null,"tags":["算法"],"id":"bloomfilter","title":"BloomFilter（布隆过滤器）介绍","date":"2018-01-15T23:22:39.000Z","published":true,"hideInList":false,"feature":null,"isTop":false}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"redis-memory-usage-analysis"},"buildId":"rQGl2E3ObLYgPNk8QlWuc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
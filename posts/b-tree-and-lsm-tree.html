<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Light Up The World</title><link rel="preload" href="/_next/static/css/c6cf52e305c0a82d.css" as="style"/><link rel="preload" href="/_next/static/css/b9a831462dbeea41.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c6cf52e305c0a82d.css" data-n-g=""/><link rel="stylesheet" href="/_next/static/css/b9a831462dbeea41.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-8cac0b4b405cede1.js" defer=""></script><script src="/_next/static/chunks/framework-7c47d0879e3fabaa.js" defer=""></script><script src="/_next/static/chunks/main-eabf4e641ff2595a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1c3b0aeaafcae3ac.js" defer=""></script><script src="/_next/static/chunks/255-556050becd2e6a51.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-6464eaa07d778f00.js" defer=""></script><script src="/_next/static/mT1FaweWnSl2HiK65X_j-/_buildManifest.js" defer=""></script><script src="/_next/static/mT1FaweWnSl2HiK65X_j-/_ssgManifest.js" defer=""></script></head><body class="antialiased"><div id="__next"><div class="Post_container__ictJu"><nav class="Nav_nav__o8sSc"><div class="Nav_navContainer__KuO9f"><a class="Nav_navLogo__aczrM" href="/">Light Ning</a><div class="Nav_navLinks__sb_3K"><a class="Nav_navLink__z2PDT " href="/">首页</a><a class="Nav_navLink__z2PDT " href="/about">关于</a></div></div></nav><main class="Post_main__X4Tic"><article class="Post_post__1KH4p"><h1 class="Post_title__pen_7">B+树和LSM树</h1><time class="Post_date__YGL_Q">2020-03-28</time><div class="Post_postTags__df1Jm"><span class="Post_postTag__j37er">算法</span></div><div class="Post_content__aWM2C"><p>介绍一下B+树和LSM树。</p>
<!-- more -->
<blockquote>
<p>无论何种存储介质，顺序读写性能都远高于随机读写性能。</p>
</blockquote>
<h1>文件索引和数据库索引</h1>
<ol>
<li>大部分用B+树，少部分用B树。</li>
<li>哈希表虽然能够在 O(1) 查找到目标数据，但要进行模糊查找的话，却只能遍历所有数据。另外如果出现了极端情况，哈希表冲突的元素太多，也会导致线性时间的查找效率的。</li>
<li>二叉查找树虽然也很快，但由于文件索引是存放在磁盘上的，所以不仅要考虑查找效率，还要考虑磁盘的寻址加载次数。</li>
</ol>
<h1>B+</h1>
<ol>
<li>B树相当于是一棵多叉查找树。</li>
<li>实际上磁盘的加载次数，基本上是和树的高度相关联的。高度越高，加载次数越多，高度越矮，加载次数越少。所以对于文件索引的存储，一般会选择矮胖的树形结构。</li>
</ol>
<h1>LSM</h1>
<ol>
<li>LSM Tree的最早概念，诞生于1996年google的“BigTable”论文。</li>
<li>要提高读写性能，思路是在落盘的数据是顺序写入的同时，还保证这些数据是有序的。这就需要利用内存访问速度比硬盘快的原理，将写入的请求先在内存中缓存起来，按一定的有序结构进行组织，达到一定量后再写入硬盘，从而使得硬盘顺序写入了有序的数据。</li>
<li>在写入时要先写一份log，防止断电时便于进行数据恢复。</li>
<li>写入数据的内存缓存，MemTable中存储的是有序的数据。这里不同的实现可能不相同，LevelDB使用的是SkipList有序结构，Hbase使用的是B Tree有序结构。</li>
<li>MemTable中的数据随时在增加，当其增加到一定量后将其变为不可变数据（ImmutableMemTable）。新生成一份MemTable用于后续的数据写入。ImmutableMemTable中的数据，将被写入到硬盘中的SSTable。</li>
<li>SSTable 全称Sorted String Table，实际上就是被写入数据的有序存储文件。</li>
<li>数据读取的大致流程：从MemTable中查找——从ImmutableMemTable中查找——从最新的SSTable中查找——从剩下的最新的SSTable中继续查找。其中还用到了布隆表达式来提高查找效率。</li>
<li>为了保证数据的顺序写，所有SSTable都不会因为删除和更新而在原数据所在位置进行更改。在更新时，是插入一个最新的值去写到新的SSTable中。在删除时，是插入一个基于该Key的删除标记，写入最新的SSTable中。由于查找某个Key是基于时间新鲜度，反向依次查找SSTable，所以读取某个Key始终读的是最新的值。</li>
<li>随着日积月累，SSTable的文件数会增多，导致查找时性能下降。同时由于数据的更新或删除，老的SSTable中数据的有效性逐渐降低，太多的过期数据会占用SSTable，同样会降低查询效率。所以一般数据库引擎，都会有一个SSTable的定期合并操作。移除过时数据，将多个小SSTable合并成大的SSTable。</li>
<li>在大内存的条件下，部分数据库还会将最近读取的SSTable索引缓存至内存中，进一步加速查找的过程。</li>
<li>采用 LSM Tree 作为存储结构的数据库有：Google的LevelDB，Facebook的RockDB（RockDB来源于LevelDB），Cassandra，HBase等。</li>
</ol>
</div></article><div class="Post_postNavigation__TSrfz"><a class="Post_navLink__iyGDb" href="/posts/crazy-html5-note">← <!-- -->疯狂HTML5讲义</a><a class="Post_navLink__iyGDb Post_nextLink__THXHn" href="/posts/elasticsearch-in-action-note">《Elasticsearch实战》阅读笔记<!-- --> →</a></div></main><footer class="footer_footer__mqdak"><p>Copyright © <!-- -->2025<!-- --> <!-- -->Light Ning<!-- -->. All rights reserved.</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"summary":null,"tags":["算法"],"id":"b-tree-and-lsm-tree","contentHtml":"\u003cp\u003e介绍一下B+树和LSM树。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003cblockquote\u003e\n\u003cp\u003e无论何种存储介质，顺序读写性能都远高于随机读写性能。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003e文件索引和数据库索引\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e大部分用B+树，少部分用B树。\u003c/li\u003e\n\u003cli\u003e哈希表虽然能够在 O(1) 查找到目标数据，但要进行模糊查找的话，却只能遍历所有数据。另外如果出现了极端情况，哈希表冲突的元素太多，也会导致线性时间的查找效率的。\u003c/li\u003e\n\u003cli\u003e二叉查找树虽然也很快，但由于文件索引是存放在磁盘上的，所以不仅要考虑查找效率，还要考虑磁盘的寻址加载次数。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1\u003eB+\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eB树相当于是一棵多叉查找树。\u003c/li\u003e\n\u003cli\u003e实际上磁盘的加载次数，基本上是和树的高度相关联的。高度越高，加载次数越多，高度越矮，加载次数越少。所以对于文件索引的存储，一般会选择矮胖的树形结构。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1\u003eLSM\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eLSM Tree的最早概念，诞生于1996年google的“BigTable”论文。\u003c/li\u003e\n\u003cli\u003e要提高读写性能，思路是在落盘的数据是顺序写入的同时，还保证这些数据是有序的。这就需要利用内存访问速度比硬盘快的原理，将写入的请求先在内存中缓存起来，按一定的有序结构进行组织，达到一定量后再写入硬盘，从而使得硬盘顺序写入了有序的数据。\u003c/li\u003e\n\u003cli\u003e在写入时要先写一份log，防止断电时便于进行数据恢复。\u003c/li\u003e\n\u003cli\u003e写入数据的内存缓存，MemTable中存储的是有序的数据。这里不同的实现可能不相同，LevelDB使用的是SkipList有序结构，Hbase使用的是B Tree有序结构。\u003c/li\u003e\n\u003cli\u003eMemTable中的数据随时在增加，当其增加到一定量后将其变为不可变数据（ImmutableMemTable）。新生成一份MemTable用于后续的数据写入。ImmutableMemTable中的数据，将被写入到硬盘中的SSTable。\u003c/li\u003e\n\u003cli\u003eSSTable 全称Sorted String Table，实际上就是被写入数据的有序存储文件。\u003c/li\u003e\n\u003cli\u003e数据读取的大致流程：从MemTable中查找——从ImmutableMemTable中查找——从最新的SSTable中查找——从剩下的最新的SSTable中继续查找。其中还用到了布隆表达式来提高查找效率。\u003c/li\u003e\n\u003cli\u003e为了保证数据的顺序写，所有SSTable都不会因为删除和更新而在原数据所在位置进行更改。在更新时，是插入一个最新的值去写到新的SSTable中。在删除时，是插入一个基于该Key的删除标记，写入最新的SSTable中。由于查找某个Key是基于时间新鲜度，反向依次查找SSTable，所以读取某个Key始终读的是最新的值。\u003c/li\u003e\n\u003cli\u003e随着日积月累，SSTable的文件数会增多，导致查找时性能下降。同时由于数据的更新或删除，老的SSTable中数据的有效性逐渐降低，太多的过期数据会占用SSTable，同样会降低查询效率。所以一般数据库引擎，都会有一个SSTable的定期合并操作。移除过时数据，将多个小SSTable合并成大的SSTable。\u003c/li\u003e\n\u003cli\u003e在大内存的条件下，部分数据库还会将最近读取的SSTable索引缓存至内存中，进一步加速查找的过程。\u003c/li\u003e\n\u003cli\u003e采用 LSM Tree 作为存储结构的数据库有：Google的LevelDB，Facebook的RockDB（RockDB来源于LevelDB），Cassandra，HBase等。\u003c/li\u003e\n\u003c/ol\u003e\n","date":"2020-03-28T10:00:00.000Z","title":"B+树和LSM树","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["HTML"],"id":"crazy-html5-note","title":"疯狂HTML5讲义","date":"2020-05-16T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false},"nextPost":{"summary":null,"tags":["Elasticsearch"],"id":"elasticsearch-in-action-note","title":"《Elasticsearch实战》阅读笔记","date":"2020-01-27T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"b-tree-and-lsm-tree"},"buildId":"mT1FaweWnSl2HiK65X_j-","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
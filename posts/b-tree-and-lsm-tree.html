<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Light Up The World</title><link rel="preload" href="/_next/static/css/88a22a97171c2361.css" as="style"/><link rel="stylesheet" href="/_next/static/css/88a22a97171c2361.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-8cac0b4b405cede1.js" defer=""></script><script src="/_next/static/chunks/framework-2f335d22a7318891.js" defer=""></script><script src="/_next/static/chunks/main-6f8766cf045e0663.js" defer=""></script><script src="/_next/static/chunks/pages/_app-395f9b40f90241c5.js" defer=""></script><script src="/_next/static/chunks/788-30228ea06843549b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-dc23e43b9d6d1438.js" defer=""></script><script src="/_next/static/q6hSQsiRimNn3FlPPs5I6/_buildManifest.js" defer=""></script><script src="/_next/static/q6hSQsiRimNn3FlPPs5I6/_ssgManifest.js" defer=""></script></head><body class="antialiased"><div id="__next"><div class="min-h-screen flex flex-col"><nav class="bg-gray-50 text-gray-700 py-4 shadow-md"><div class="flex justify-between items-center max-w-7xl mx-auto px-4"><a class="text-2xl font-bold bg-gradient-to-r from-blue-600 to-blue-900 bg-clip-text text-transparent" href="/">Light Ning</a><div class="flex gap-6"><a class="text-gray-700 font-medium transition-all duration-200 px-2 py-1 rounded hover:bg-gray-100 hover:text-blue-600" href="/">首页</a><a class="text-gray-700 font-medium transition-all duration-200 px-2 py-1 rounded hover:bg-gray-100 hover:text-blue-600" href="/about">关于</a></div></div></nav><main class="flex-1 py-8 max-w-5xl mx-auto w-full"><article class="bg-white rounded-lg p-8 shadow-sm"><h1 class="text-3xl font-bold text-gray-700 mb-2 text-center">B+树和LSM树</h1><time class="block text-sm text-gray-600 mb-8 text-center">2020-03-28</time><div class="prose max-w-none text-gray-700"><blockquote>
<p>无论何种存储介质，顺序读写性能都远高于随机读写性能。</p>
</blockquote>
<h1>文件索引和数据库索引</h1>
<ol>
<li>大部分用B+树，少部分用B树。</li>
<li>哈希表虽然能够在 O(1) 查找到目标数据，但要进行模糊查找的话，却只能遍历所有数据。另外如果出现了极端情况，哈希表冲突的元素太多，也会导致线性时间的查找效率的。</li>
<li>二叉查找树虽然也很快，但由于文件索引是存放在磁盘上的，所以不仅要考虑查找效率，还要考虑磁盘的寻址加载次数。</li>
</ol>
<h1>B+</h1>
<ol>
<li>B树相当于是一棵多叉查找树。</li>
<li>实际上磁盘的加载次数，基本上是和树的高度相关联的。高度越高，加载次数越多，高度越矮，加载次数越少。所以对于文件索引的存储，一般会选择矮胖的树形结构。</li>
</ol>
<h1>LSM</h1>
<ol>
<li>LSM Tree的最早概念，诞生于1996年google的“BigTable”论文。</li>
<li>要提高读写性能，思路是在落盘的数据是顺序写入的同时，还保证这些数据是有序的。这就需要利用内存访问速度比硬盘快的原理，将写入的请求先在内存中缓存起来，按一定的有序结构进行组织，达到一定量后再写入硬盘，从而使得硬盘顺序写入了有序的数据。</li>
<li>在写入时要先写一份log，防止断电时便于进行数据恢复。</li>
<li>写入数据的内存缓存，MemTable中存储的是有序的数据。这里不同的实现可能不相同，LevelDB使用的是SkipList有序结构，Hbase使用的是B Tree有序结构。</li>
<li>MemTable中的数据随时在增加，当其增加到一定量后将其变为不可变数据（ImmutableMemTable）。新生成一份MemTable用于后续的数据写入。ImmutableMemTable中的数据，将被写入到硬盘中的SSTable。</li>
<li>SSTable 全称Sorted String Table，实际上就是被写入数据的有序存储文件。</li>
<li>数据读取的大致流程：从MemTable中查找——从ImmutableMemTable中查找——从最新的SSTable中查找——从剩下的最新的SSTable中继续查找。其中还用到了布隆表达式来提高查找效率。</li>
<li>为了保证数据的顺序写，所有SSTable都不会因为删除和更新而在原数据所在位置进行更改。在更新时，是插入一个最新的值去写到新的SSTable中。在删除时，是插入一个基于该Key的删除标记，写入最新的SSTable中。由于查找某个Key是基于时间新鲜度，反向依次查找SSTable，所以读取某个Key始终读的是最新的值。</li>
<li>随着日积月累，SSTable的文件数会增多，导致查找时性能下降。同时由于数据的更新或删除，老的SSTable中数据的有效性逐渐降低，太多的过期数据会占用SSTable，同样会降低查询效率。所以一般数据库引擎，都会有一个SSTable的定期合并操作。移除过时数据，将多个小SSTable合并成大的SSTable。</li>
<li>在大内存的条件下，部分数据库还会将最近读取的SSTable索引缓存至内存中，进一步加速查找的过程。</li>
<li>采用 LSM Tree 作为存储结构的数据库有：Google的LevelDB，Facebook的RockDB（RockDB来源于LevelDB），Cassandra，HBase等。</li>
</ol>
</div><div class="flex flex-wrap gap-2 mt-8"><span class="bg-gray-100 text-gray-700 text-sm px-2 py-1 rounded-full">算法</span></div></article><div class="mt-12 border-t border-gray-200 pt-8 flex justify-between"><a class="text-blue-600 hover:underline flex items-center" href="/posts/crazy-html5-note"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-2"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5"></path></svg>疯狂HTML5讲义</a><a class="text-blue-600 hover:underline flex items-center" href="/posts/elasticsearch-in-action-note">《Elasticsearch实战》阅读笔记<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 ml-2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5"></path></svg></a></div></main><footer class="text-center bg-gray-50 text-gray-700 py-4 shadow-md mt-8"><p>Copyright © <!-- -->2025<!-- --> <!-- -->Light Ning<!-- -->. All rights reserved.</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"summary":null,"tags":["算法"],"id":"b-tree-and-lsm-tree","contentHtml":"\u003cblockquote\u003e\n\u003cp\u003e无论何种存储介质，顺序读写性能都远高于随机读写性能。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003e文件索引和数据库索引\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e大部分用B+树，少部分用B树。\u003c/li\u003e\n\u003cli\u003e哈希表虽然能够在 O(1) 查找到目标数据，但要进行模糊查找的话，却只能遍历所有数据。另外如果出现了极端情况，哈希表冲突的元素太多，也会导致线性时间的查找效率的。\u003c/li\u003e\n\u003cli\u003e二叉查找树虽然也很快，但由于文件索引是存放在磁盘上的，所以不仅要考虑查找效率，还要考虑磁盘的寻址加载次数。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1\u003eB+\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eB树相当于是一棵多叉查找树。\u003c/li\u003e\n\u003cli\u003e实际上磁盘的加载次数，基本上是和树的高度相关联的。高度越高，加载次数越多，高度越矮，加载次数越少。所以对于文件索引的存储，一般会选择矮胖的树形结构。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1\u003eLSM\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eLSM Tree的最早概念，诞生于1996年google的“BigTable”论文。\u003c/li\u003e\n\u003cli\u003e要提高读写性能，思路是在落盘的数据是顺序写入的同时，还保证这些数据是有序的。这就需要利用内存访问速度比硬盘快的原理，将写入的请求先在内存中缓存起来，按一定的有序结构进行组织，达到一定量后再写入硬盘，从而使得硬盘顺序写入了有序的数据。\u003c/li\u003e\n\u003cli\u003e在写入时要先写一份log，防止断电时便于进行数据恢复。\u003c/li\u003e\n\u003cli\u003e写入数据的内存缓存，MemTable中存储的是有序的数据。这里不同的实现可能不相同，LevelDB使用的是SkipList有序结构，Hbase使用的是B Tree有序结构。\u003c/li\u003e\n\u003cli\u003eMemTable中的数据随时在增加，当其增加到一定量后将其变为不可变数据（ImmutableMemTable）。新生成一份MemTable用于后续的数据写入。ImmutableMemTable中的数据，将被写入到硬盘中的SSTable。\u003c/li\u003e\n\u003cli\u003eSSTable 全称Sorted String Table，实际上就是被写入数据的有序存储文件。\u003c/li\u003e\n\u003cli\u003e数据读取的大致流程：从MemTable中查找——从ImmutableMemTable中查找——从最新的SSTable中查找——从剩下的最新的SSTable中继续查找。其中还用到了布隆表达式来提高查找效率。\u003c/li\u003e\n\u003cli\u003e为了保证数据的顺序写，所有SSTable都不会因为删除和更新而在原数据所在位置进行更改。在更新时，是插入一个最新的值去写到新的SSTable中。在删除时，是插入一个基于该Key的删除标记，写入最新的SSTable中。由于查找某个Key是基于时间新鲜度，反向依次查找SSTable，所以读取某个Key始终读的是最新的值。\u003c/li\u003e\n\u003cli\u003e随着日积月累，SSTable的文件数会增多，导致查找时性能下降。同时由于数据的更新或删除，老的SSTable中数据的有效性逐渐降低，太多的过期数据会占用SSTable，同样会降低查询效率。所以一般数据库引擎，都会有一个SSTable的定期合并操作。移除过时数据，将多个小SSTable合并成大的SSTable。\u003c/li\u003e\n\u003cli\u003e在大内存的条件下，部分数据库还会将最近读取的SSTable索引缓存至内存中，进一步加速查找的过程。\u003c/li\u003e\n\u003cli\u003e采用 LSM Tree 作为存储结构的数据库有：Google的LevelDB，Facebook的RockDB（RockDB来源于LevelDB），Cassandra，HBase等。\u003c/li\u003e\n\u003c/ol\u003e\n","date":"2020-03-28","title":"B+树和LSM树"},"prevPost":{"summary":null,"tags":["HTML"],"id":"crazy-html5-note","title":"疯狂HTML5讲义","date":"2020-05-16"},"nextPost":{"summary":null,"tags":["Elasticsearch"],"id":"elasticsearch-in-action-note","title":"《Elasticsearch实战》阅读笔记","date":"2020-01-27"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"b-tree-and-lsm-tree"},"buildId":"q6hSQsiRimNn3FlPPs5I6","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Light Up The World</title><link rel="preload" href="/_next/static/css/033adb5b5f286c01.css" as="style"/><link rel="stylesheet" href="/_next/static/css/033adb5b5f286c01.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-8cac0b4b405cede1.js" defer=""></script><script src="/_next/static/chunks/framework-7c47d0879e3fabaa.js" defer=""></script><script src="/_next/static/chunks/main-eabf4e641ff2595a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1c3b0aeaafcae3ac.js" defer=""></script><script src="/_next/static/chunks/493-7bce3a15b2a5d2a7.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-07cfa332a03d2f2c.js" defer=""></script><script src="/_next/static/BnePagLkZet_CJv8kEPQq/_buildManifest.js" defer=""></script><script src="/_next/static/BnePagLkZet_CJv8kEPQq/_ssgManifest.js" defer=""></script></head><body class="antialiased"><div id="__next"><div class="min-h-screen flex flex-col"><nav class="bg-gray-50 text-gray-700 py-4 shadow-md"><div class="flex justify-between items-center max-w-7xl mx-auto px-4"><a class="text-2xl font-bold bg-gradient-to-r from-blue-600 to-blue-900 bg-clip-text text-transparent" href="/">Light Ning</a><div class="flex gap-6"><a class="text-gray-700 font-medium transition-all duration-200 px-2 py-1 rounded hover:bg-gray-100 hover:text-blue-600" href="/">首页</a><a class="text-gray-700 font-medium transition-all duration-200 px-2 py-1 rounded hover:bg-gray-100 hover:text-blue-600" href="/about">关于</a></div></div></nav><main class="flex-1 py-8 max-w-5xl mx-auto w-full"><article class="bg-white rounded-lg p-8 shadow-sm"><h1 class="text-3xl font-bold text-gray-700 mb-2 text-center">Kafka的高可用和高性能实现</h1><time class="block text-sm text-gray-600 mb-8 text-center">2018-06-13</time><div class="prose max-w-none text-gray-700 markdown"><h1>Kafka高可用</h1>
<h3>1. 副本机制</h3>
<p>副本机制会将一个broker下某个topic的一个partition放入到另外一个broker里，这个备份的分区和原分区都叫做副本（replica）。在所有的副本里，只能有一个leader，其余的副本都作为follower，同一时间内只有leader负责读写，follower不起任何作用。其他所有的follower会异步的拉取leader消息。当leader挂掉之后，为了保证高可用性，会从中选择一个副本作为leader。</p>
<h1>Kafka高性能</h1>
<h3>1. 分区</h3>
<p>Kafka将topic分区，每一个broker里面会保存topic的不同分区，这样就可以让一个消费者组同时消费不同的分区，提高吞吐。</p>
<h3>2. 页缓存</h3>
<p>Kafka将数据写入页缓存（内存）中而不直接操作磁盘，由操作系统决定什么时候把页缓存中数据刷到磁盘上。同时写入页缓存的数据是按照磁盘顺序去写入的，因此刷到磁盘上的速度也较快。当读操作发生时，先从页缓存中查询是否有所需信息，若没有才会调度磁盘。</p>
<h3>3. 零拷贝——PageCache 结合 sendfile 方法</h3>
<p>若页缓存中没有所需信息，需要去调度磁盘数据。一般网络io操作需要四个步骤 ： 硬盘 -> 内核态 PageCache -> 用户态程序读取 -> 内核态socket写入 -> 拷贝至网卡。通过Sendfile优化后，使用零拷贝可以将buffer从内核态和用户态间任意切换。PageCache仅会传递一个文件描述符给socket，就等效于直接从PageCache中拷贝至网卡，从而少了两步IO操作。</p>
<h1>Leader的选举</h1>
<h3>1. Leader宕机</h3>
<p>如果Leader宕机了该怎么办？很容易想到在Follower中重新选举⼀个Leader，但是选举哪个作为leader呢？Follower可能已经落后许多了，因此要选择的是“最新”的Follower：新的Leader必须拥有与原来Leader commit过的所有信息。
kafka动态维护了⼀组同步leader数据的副本（ISR），只有这个组的成员才有资格当选leader。kafka副本写⼊不被认为是已提交，直到所有的同步副本已经接收才认为是。这组ISR保存在zookeeper，正因为如此，在ISR中的任何副本都有资格当选leader。</p>
<h3>2. 如果Replica都死了怎么办</h3>
<p>只要⾄少有⼀个replica，就能保证数据不丢失，可是如果某个partition的所有replica都死了怎么办？有两种⽅案：
（1）等待在ISR中的副本恢复，并选择该副本作为Leader；
（2）选择第⼀个活过来的副本（不⼀定在 ISR中)，作为Leader
这里存在可⽤性和⼀致性的⽭盾：如果⼀定要等待副本恢复，等待的时间可能⽐较⻓，甚⾄可能永远不可⽤。如果是第⼆种，不能保证所有已经commit的消息不丢失，但有可⽤性。Kafka默认选⽤第⼆种⽅式，⽀持选择不能保证⼀致的副本。可以通过参数unclean.leader.election.enable禁⽤它。</p>
</div><div class="flex flex-wrap gap-2 mt-8"><span class="bg-gray-100 text-gray-700 text-sm px-2 py-1 rounded-full">Kafka</span></div></article><div class="mt-12 border-t border-gray-200 pt-8 flex justify-between"><a class="text-blue-600 hover:underline flex items-center" href="/posts/golang-open-source-components-list"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-2"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5"></path></svg>Go的一些常用开源组件列表</a><a class="text-blue-600 hover:underline flex items-center" href="/posts/grpc-intro">gRPC介绍<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 ml-2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5"></path></svg></a></div></main><footer class="text-center bg-gray-50 text-gray-700 py-4 shadow-md mt-8"><p>Copyright © <!-- -->2025<!-- --> <!-- -->Light Ning<!-- -->. All rights reserved.</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"summary":null,"tags":["Kafka"],"id":"kafka-high-availability-and-high-performance","contentHtml":"\u003ch1\u003eKafka高可用\u003c/h1\u003e\n\u003ch3\u003e1. 副本机制\u003c/h3\u003e\n\u003cp\u003e副本机制会将一个broker下某个topic的一个partition放入到另外一个broker里，这个备份的分区和原分区都叫做副本（replica）。在所有的副本里，只能有一个leader，其余的副本都作为follower，同一时间内只有leader负责读写，follower不起任何作用。其他所有的follower会异步的拉取leader消息。当leader挂掉之后，为了保证高可用性，会从中选择一个副本作为leader。\u003c/p\u003e\n\u003ch1\u003eKafka高性能\u003c/h1\u003e\n\u003ch3\u003e1. 分区\u003c/h3\u003e\n\u003cp\u003eKafka将topic分区，每一个broker里面会保存topic的不同分区，这样就可以让一个消费者组同时消费不同的分区，提高吞吐。\u003c/p\u003e\n\u003ch3\u003e2. 页缓存\u003c/h3\u003e\n\u003cp\u003eKafka将数据写入页缓存（内存）中而不直接操作磁盘，由操作系统决定什么时候把页缓存中数据刷到磁盘上。同时写入页缓存的数据是按照磁盘顺序去写入的，因此刷到磁盘上的速度也较快。当读操作发生时，先从页缓存中查询是否有所需信息，若没有才会调度磁盘。\u003c/p\u003e\n\u003ch3\u003e3. 零拷贝——PageCache 结合 sendfile 方法\u003c/h3\u003e\n\u003cp\u003e若页缓存中没有所需信息，需要去调度磁盘数据。一般网络io操作需要四个步骤 ： 硬盘 -\u003e 内核态 PageCache -\u003e 用户态程序读取 -\u003e 内核态socket写入 -\u003e 拷贝至网卡。通过Sendfile优化后，使用零拷贝可以将buffer从内核态和用户态间任意切换。PageCache仅会传递一个文件描述符给socket，就等效于直接从PageCache中拷贝至网卡，从而少了两步IO操作。\u003c/p\u003e\n\u003ch1\u003eLeader的选举\u003c/h1\u003e\n\u003ch3\u003e1. Leader宕机\u003c/h3\u003e\n\u003cp\u003e如果Leader宕机了该怎么办？很容易想到在Follower中重新选举⼀个Leader，但是选举哪个作为leader呢？Follower可能已经落后许多了，因此要选择的是“最新”的Follower：新的Leader必须拥有与原来Leader commit过的所有信息。\nkafka动态维护了⼀组同步leader数据的副本（ISR），只有这个组的成员才有资格当选leader。kafka副本写⼊不被认为是已提交，直到所有的同步副本已经接收才认为是。这组ISR保存在zookeeper，正因为如此，在ISR中的任何副本都有资格当选leader。\u003c/p\u003e\n\u003ch3\u003e2. 如果Replica都死了怎么办\u003c/h3\u003e\n\u003cp\u003e只要⾄少有⼀个replica，就能保证数据不丢失，可是如果某个partition的所有replica都死了怎么办？有两种⽅案：\n（1）等待在ISR中的副本恢复，并选择该副本作为Leader；\n（2）选择第⼀个活过来的副本（不⼀定在 ISR中)，作为Leader\n这里存在可⽤性和⼀致性的⽭盾：如果⼀定要等待副本恢复，等待的时间可能⽐较⻓，甚⾄可能永远不可⽤。如果是第⼆种，不能保证所有已经commit的消息不丢失，但有可⽤性。Kafka默认选⽤第⼆种⽅式，⽀持选择不能保证⼀致的副本。可以通过参数unclean.leader.election.enable禁⽤它。\u003c/p\u003e\n","date":"2018-06-13","title":"Kafka的高可用和高性能实现"},"prevPost":{"summary":null,"tags":["Golang"],"id":"golang-open-source-components-list","title":"Go的一些常用开源组件列表","date":"2018-07-10"},"nextPost":{"summary":null,"tags":["Golang","微服务"],"id":"grpc-intro","title":"gRPC介绍","date":"2018-04-06"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"kafka-high-availability-and-high-performance"},"buildId":"BnePagLkZet_CJv8kEPQq","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
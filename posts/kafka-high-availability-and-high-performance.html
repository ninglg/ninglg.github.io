<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Light Up The World</title><link rel="preload" href="/_next/static/css/f746a819331ac28f.css" as="style"/><link rel="preload" href="/_next/static/css/67a8467bbb0bf2f3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f746a819331ac28f.css" data-n-g=""/><link rel="stylesheet" href="/_next/static/css/67a8467bbb0bf2f3.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-8cac0b4b405cede1.js" defer=""></script><script src="/_next/static/chunks/framework-2f335d22a7318891.js" defer=""></script><script src="/_next/static/chunks/main-6f8766cf045e0663.js" defer=""></script><script src="/_next/static/chunks/pages/_app-395f9b40f90241c5.js" defer=""></script><script src="/_next/static/chunks/8-20d97a1f65308574.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-f6a8d15cf5758418.js" defer=""></script><script src="/_next/static/19D7Ntg06Lp4t0-2KoMZC/_buildManifest.js" defer=""></script><script src="/_next/static/19D7Ntg06Lp4t0-2KoMZC/_ssgManifest.js" defer=""></script></head><body class="antialiased"><div id="__next"><div class="Post_container__ictJu"><nav class="Nav_nav__o8sSc"><div class="Nav_navContainer__KuO9f"><a class="Nav_navLogo__aczrM" href="/">Light Ning</a><div class="Nav_navLinks__sb_3K"><a class="Nav_navLink__z2PDT " href="/">首页</a><a class="Nav_navLink__z2PDT " href="/about">关于</a></div></div></nav><main class="Post_main__X4Tic"><article class="Post_post__1KH4p"><h1 class="Post_title__pen_7">Kafka的高可用和高性能实现</h1><time class="Post_date__YGL_Q">2018-06-13</time><div class="Post_postTags__df1Jm"><span class="Post_postTag__j37er">Kafka</span></div><div class="Post_content__aWM2C"><p>Kafka的高可用和高性能实现</p>
<h1>Kafka高可用</h1>
<h3>1. 副本机制</h3>
<p>副本机制会将一个broker下某个topic的一个partition放入到另外一个broker里，这个备份的分区和原分区都叫做副本（replica）。在所有的副本里，只能有一个leader，其余的副本都作为follower，同一时间内只有leader负责读写，follower不起任何作用。其他所有的follower会异步的拉取leader消息。当leader挂掉之后，为了保证高可用性，会从中选择一个副本作为leader。</p>
<h1>Kafka高性能</h1>
<h3>1. 分区</h3>
<p>Kafka将topic分区，每一个broker里面会保存topic的不同分区，这样就可以让一个消费者组同时消费不同的分区，提高吞吐。</p>
<h3>2. 页缓存</h3>
<p>Kafka将数据写入页缓存（内存）中而不直接操作磁盘，由操作系统决定什么时候把页缓存中数据刷到磁盘上。同时写入页缓存的数据是按照磁盘顺序去写入的，因此刷到磁盘上的速度也较快。当读操作发生时，先从页缓存中查询是否有所需信息，若没有才会调度磁盘。</p>
<h3>3. 零拷贝——PageCache 结合 sendfile 方法</h3>
<p>若页缓存中没有所需信息，需要去调度磁盘数据。一般网络io操作需要四个步骤 ： 硬盘 -> 内核态 PageCache -> 用户态程序读取 -> 内核态socket写入 -> 拷贝至网卡。通过Sendfile优化后，使用零拷贝可以将buffer从内核态和用户态间任意切换。PageCache仅会传递一个文件描述符给socket，就等效于直接从PageCache中拷贝至网卡，从而少了两步IO操作。</p>
<h1>Leader的选举</h1>
<h3>1. Leader宕机</h3>
<p>如果Leader宕机了该怎么办？很容易想到在Follower中重新选举⼀个Leader，但是选举哪个作为leader呢？Follower可能已经落后许多了，因此要选择的是“最新”的Follower：新的Leader必须拥有与原来Leader commit过的所有信息。
kafka动态维护了⼀组同步leader数据的副本（ISR），只有这个组的成员才有资格当选leader。kafka副本写⼊不被认为是已提交，直到所有的同步副本已经接收才认为是。这组ISR保存在zookeeper，正因为如此，在ISR中的任何副本都有资格当选leader。</p>
<h3>2. 如果Replica都死了怎么办</h3>
<p>只要⾄少有⼀个replica，就能保证数据不丢失，可是如果某个partition的所有replica都死了怎么办？有两种⽅案：
（1）等待在ISR中的副本恢复，并选择该副本作为Leader；
（2）选择第⼀个活过来的副本（不⼀定在 ISR中)，作为Leader
这里存在可⽤性和⼀致性的⽭盾：如果⼀定要等待副本恢复，等待的时间可能⽐较⻓，甚⾄可能永远不可⽤。如果是第⼆种，不能保证所有已经commit的消息不丢失，但有可⽤性。Kafka默认选⽤第⼆种⽅式，⽀持选择不能保证⼀致的副本。可以通过参数unclean.leader.election.enable禁⽤它。</p>
</div></article><div class="Post_postNavigation__TSrfz"><a class="Post_navLink__iyGDb" href="/posts/golang-open-source-components-list">← <!-- -->Go的一些常用开源组件列表</a><a class="Post_navLink__iyGDb Post_nextLink__THXHn" href="/posts/grpc-intro">gRPC介绍<!-- --> →</a></div></main><footer class="footer_footer__mqdak"><p>Copyright © <!-- -->2025<!-- --> <!-- -->Light Ning<!-- -->. All rights reserved.</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"summary":null,"tags":["Kafka"],"id":"kafka-high-availability-and-high-performance","contentHtml":"\u003cp\u003eKafka的高可用和高性能实现\u003c/p\u003e\n\u003ch1\u003eKafka高可用\u003c/h1\u003e\n\u003ch3\u003e1. 副本机制\u003c/h3\u003e\n\u003cp\u003e副本机制会将一个broker下某个topic的一个partition放入到另外一个broker里，这个备份的分区和原分区都叫做副本（replica）。在所有的副本里，只能有一个leader，其余的副本都作为follower，同一时间内只有leader负责读写，follower不起任何作用。其他所有的follower会异步的拉取leader消息。当leader挂掉之后，为了保证高可用性，会从中选择一个副本作为leader。\u003c/p\u003e\n\u003ch1\u003eKafka高性能\u003c/h1\u003e\n\u003ch3\u003e1. 分区\u003c/h3\u003e\n\u003cp\u003eKafka将topic分区，每一个broker里面会保存topic的不同分区，这样就可以让一个消费者组同时消费不同的分区，提高吞吐。\u003c/p\u003e\n\u003ch3\u003e2. 页缓存\u003c/h3\u003e\n\u003cp\u003eKafka将数据写入页缓存（内存）中而不直接操作磁盘，由操作系统决定什么时候把页缓存中数据刷到磁盘上。同时写入页缓存的数据是按照磁盘顺序去写入的，因此刷到磁盘上的速度也较快。当读操作发生时，先从页缓存中查询是否有所需信息，若没有才会调度磁盘。\u003c/p\u003e\n\u003ch3\u003e3. 零拷贝——PageCache 结合 sendfile 方法\u003c/h3\u003e\n\u003cp\u003e若页缓存中没有所需信息，需要去调度磁盘数据。一般网络io操作需要四个步骤 ： 硬盘 -\u003e 内核态 PageCache -\u003e 用户态程序读取 -\u003e 内核态socket写入 -\u003e 拷贝至网卡。通过Sendfile优化后，使用零拷贝可以将buffer从内核态和用户态间任意切换。PageCache仅会传递一个文件描述符给socket，就等效于直接从PageCache中拷贝至网卡，从而少了两步IO操作。\u003c/p\u003e\n\u003ch1\u003eLeader的选举\u003c/h1\u003e\n\u003ch3\u003e1. Leader宕机\u003c/h3\u003e\n\u003cp\u003e如果Leader宕机了该怎么办？很容易想到在Follower中重新选举⼀个Leader，但是选举哪个作为leader呢？Follower可能已经落后许多了，因此要选择的是“最新”的Follower：新的Leader必须拥有与原来Leader commit过的所有信息。\nkafka动态维护了⼀组同步leader数据的副本（ISR），只有这个组的成员才有资格当选leader。kafka副本写⼊不被认为是已提交，直到所有的同步副本已经接收才认为是。这组ISR保存在zookeeper，正因为如此，在ISR中的任何副本都有资格当选leader。\u003c/p\u003e\n\u003ch3\u003e2. 如果Replica都死了怎么办\u003c/h3\u003e\n\u003cp\u003e只要⾄少有⼀个replica，就能保证数据不丢失，可是如果某个partition的所有replica都死了怎么办？有两种⽅案：\n（1）等待在ISR中的副本恢复，并选择该副本作为Leader；\n（2）选择第⼀个活过来的副本（不⼀定在 ISR中)，作为Leader\n这里存在可⽤性和⼀致性的⽭盾：如果⼀定要等待副本恢复，等待的时间可能⽐较⻓，甚⾄可能永远不可⽤。如果是第⼆种，不能保证所有已经commit的消息不丢失，但有可⽤性。Kafka默认选⽤第⼆种⽅式，⽀持选择不能保证⼀致的副本。可以通过参数unclean.leader.election.enable禁⽤它。\u003c/p\u003e\n","date":"2018-06-13T10:00:00.000Z","title":"Kafka的高可用和高性能实现","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["Golang"],"id":"golang-open-source-components-list","title":"Go的一些常用开源组件列表","date":"2018-07-10T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false},"nextPost":{"summary":null,"tags":["Golang","微服务"],"id":"grpc-intro","title":"gRPC介绍","date":"2018-04-06T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"kafka-high-availability-and-high-performance"},"buildId":"19D7Ntg06Lp4t0-2KoMZC","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Light Up The World</title><link rel="preload" href="/_next/static/css/f746a819331ac28f.css" as="style"/><link rel="preload" href="/_next/static/css/67a8467bbb0bf2f3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f746a819331ac28f.css" data-n-g=""/><link rel="stylesheet" href="/_next/static/css/67a8467bbb0bf2f3.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-0d0518cf5dc92fa8.js" defer=""></script><script src="/_next/static/chunks/framework-3b42cd6c159eee45.js" defer=""></script><script src="/_next/static/chunks/main-3a6cdb4de470543c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b1567c0152ea5cdf.js" defer=""></script><script src="/_next/static/chunks/8-69a6136648adcc6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-71ee397017ad762c.js" defer=""></script><script src="/_next/static/rQGl2E3ObLYgPNk8QlWuc/_buildManifest.js" defer=""></script><script src="/_next/static/rQGl2E3ObLYgPNk8QlWuc/_ssgManifest.js" defer=""></script></head><body class="antialiased"><div id="__next"><div class="Post_container__ictJu"><nav class="Nav_nav__o8sSc"><div class="Nav_navContainer__KuO9f"><a class="Nav_navLogo__aczrM" href="/">Light Ning</a><div class="Nav_navLinks__sb_3K"><a class="Nav_navLink__z2PDT " href="/">首页</a><a class="Nav_navLink__z2PDT " href="/about">关于</a></div></div></nav><main class="Post_main__X4Tic"><article class="Post_post__1KH4p"><h1 class="Post_title__pen_7">浅谈消息队列（Kafka、RabbitMQ、RocketMQ等）</h1><time class="Post_date__YGL_Q">2017-11-30</time><div class="Post_postTags__df1Jm"><span class="Post_postTag__j37er">Kafka</span></div><div class="Post_content__aWM2C"><p>此篇简单聊一下消息队列方面的内容。</p>
<p>消息队列（message queue）是一个经常用到的中间件技术。</p>
<h2>消息队列的作用</h2>
<ol>
<li>解耦应用</li>
<li>异步化消息</li>
<li>流量削峰填谷</li>
<li>最终一致性（最终一致性不是消息队列的必备特性，但确实可以依靠消息队列来做最终一致性的事情。）</li>
<li>广播</li>
</ol>
<h2>常见的消息队列组件</h2>
<p>常见的消息队列组件主要有：
<strong>1. Kafka（Scala开发）
2. RocketMQ（Java开发，设计时参考了 Kafka，并做出了自己的一些改进）
3. RabbitMQ（erlang开发）
4. ActiveMQ（Java开发）
5. ZeroMQ（C开发）</strong></p>
<h2>优劣势综合对比</h2>
<p>虽然消息队列组件众多，但最常见的还是Kafka和RocketMQ两种。它们的一些对比如下：</p>
<p>|  特性  |  Kafka  |  RocketMQ  |  RabbitMQ  |
|  ----  |  ----  |  ----  |  ----  |
|  开发语言  |  Scala  |  Java  |  Erlang  |
|  单机吞吐量  |  10万级，单机写入TPS约在百万条/秒，吞吐量三者最高  |  10万级  |  不到10万
|  时效性  |  ms级以内  |  ms级  |
|  可用性  |  非常高（分布式架构）  |  非常高（分布式架构）  |
|  功能特性  |  主要应用于日志采集/大数据实时计算领域，支持主要的MQ功能，不支持消息查询，支持按Offset进行消息回溯  |  功能完备，扩展性佳，经过参数优化配置消息可以做到0丢失，支持根据Message Id查询消息也支持根据消息内容查询消息，持按照时间来回溯消息精度达毫秒  |  基于AMQP协议实现，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次  |
|  缺点  | 单机队列load过多会导致发送消息响应时间变长，短轮询的方式决定了实时性取决于轮询间隔时间，消费失败不支持重试，支持消息顺序但是一台代理宕机后就会产生消息乱序  |  可能需要自己定制不同语言的client  |
|  其它特点  |  基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务  |  天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binlog分发等场景。  |
<img src="https://ninglg.com/post-images/1582818700523.jpg" alt=""></p>
<h2>关于消息丢失的问题</h2>
<ol>
<li>Kafka如何配置不当会丢消息</li>
</ol>
<ul>
<li><strong>消息落盘时机</strong>：消息落盘有异步刷新和同步刷新两种，明显异步刷新的可靠性要高很多。但在某些场景下追求性能而忽略可靠性，可以启用。</li>
<li><strong>消息存储维护</strong>：在机器或存储环境发生变化时，可能丢失数据。</li>
</ul>
<ol start="2">
<li>RocketMQ如何保证不丢消息</li>
</ol>
<ul>
<li>采用<strong>同步阻塞</strong>的发送方式，同步等待发送结果，利用<strong>同步发送+重试机制+多个master节点</strong>，尽可能减小消息丢失的可能性。</li>
<li>consumer端要保证消费消息的可靠性，主要通过<strong>At least Once+消费重试机制</strong>保证。</li>
</ul>
<h2>RabbitMQ</h2>
<p>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP，SMTP，STOMP。它比较重量级，更适合企业级的开发。</p>
<h2>Redis</h2>
<ol>
<li>使用Redis做队列有局限性，当数据大小超过了10K，Redis就慢的无法忍受。</li>
<li>Redis做队列没有ack机制保障。</li>
<li>Redis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用 rpush/lpush 操作入队列，使用 lpop / rpop 来出队列。</li>
<li>如果redis的队列空了，客户端会陷入 pop 的死循环。不停地 pop 但没有数据，这就是浪费生命的空轮询。空轮询不但拉高了客户端的 CPU，redis 的 QPS 也会被拉高。解决这个问题的办法是使用 blpop/brpop。这两个指令的前缀字符b代表的是blocking，也就是“阻塞读”。阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。消息的延迟几乎为零。用blpop/brpop替代前面的lpop/rpop。</li>
</ol>
</div></article><div class="Post_postNavigation__TSrfz"><a class="Post_navLink__iyGDb" href="/posts/vuejs-practice">← <!-- -->Vue.js 实践</a><a class="Post_navLink__iyGDb Post_nextLink__THXHn" href="/posts/paxos-and-raft-consistency-algorithm-in-distributed-system">分布式中的一致性算法：Paxos和Raft<!-- --> →</a></div></main><footer class="footer_footer__mqdak"><p>© <!-- -->2025<!-- --> <!-- -->Light Ning<!-- --> All rights reserved.</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"summary":null,"tags":["Kafka"],"id":"talk-about-message-queue","contentHtml":"\u003cp\u003e此篇简单聊一下消息队列方面的内容。\u003c/p\u003e\n\u003cp\u003e消息队列（message queue）是一个经常用到的中间件技术。\u003c/p\u003e\n\u003ch2\u003e消息队列的作用\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e解耦应用\u003c/li\u003e\n\u003cli\u003e异步化消息\u003c/li\u003e\n\u003cli\u003e流量削峰填谷\u003c/li\u003e\n\u003cli\u003e最终一致性（最终一致性不是消息队列的必备特性，但确实可以依靠消息队列来做最终一致性的事情。）\u003c/li\u003e\n\u003cli\u003e广播\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e常见的消息队列组件\u003c/h2\u003e\n\u003cp\u003e常见的消息队列组件主要有：\n\u003cstrong\u003e1. Kafka（Scala开发）\n2. RocketMQ（Java开发，设计时参考了 Kafka，并做出了自己的一些改进）\n3. RabbitMQ（erlang开发）\n4. ActiveMQ（Java开发）\n5. ZeroMQ（C开发）\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003e优劣势综合对比\u003c/h2\u003e\n\u003cp\u003e虽然消息队列组件众多，但最常见的还是Kafka和RocketMQ两种。它们的一些对比如下：\u003c/p\u003e\n\u003cp\u003e|  特性  |  Kafka  |  RocketMQ  |  RabbitMQ  |\n|  ----  |  ----  |  ----  |  ----  |\n|  开发语言  |  Scala  |  Java  |  Erlang  |\n|  单机吞吐量  |  10万级，单机写入TPS约在百万条/秒，吞吐量三者最高  |  10万级  |  不到10万\n|  时效性  |  ms级以内  |  ms级  |\n|  可用性  |  非常高（分布式架构）  |  非常高（分布式架构）  |\n|  功能特性  |  主要应用于日志采集/大数据实时计算领域，支持主要的MQ功能，不支持消息查询，支持按Offset进行消息回溯  |  功能完备，扩展性佳，经过参数优化配置消息可以做到0丢失，支持根据Message Id查询消息也支持根据消息内容查询消息，持按照时间来回溯消息精度达毫秒  |  基于AMQP协议实现，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次  |\n|  缺点  | 单机队列load过多会导致发送消息响应时间变长，短轮询的方式决定了实时性取决于轮询间隔时间，消费失败不支持重试，支持消息顺序但是一台代理宕机后就会产生消息乱序  |  可能需要自己定制不同语言的client  |\n|  其它特点  |  基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务  |  天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binlog分发等场景。  |\n\u003cimg src=\"https://ninglg.com/post-images/1582818700523.jpg\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2\u003e关于消息丢失的问题\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eKafka如何配置不当会丢消息\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e消息落盘时机\u003c/strong\u003e：消息落盘有异步刷新和同步刷新两种，明显异步刷新的可靠性要高很多。但在某些场景下追求性能而忽略可靠性，可以启用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e消息存储维护\u003c/strong\u003e：在机器或存储环境发生变化时，可能丢失数据。\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eRocketMQ如何保证不丢消息\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e采用\u003cstrong\u003e同步阻塞\u003c/strong\u003e的发送方式，同步等待发送结果，利用\u003cstrong\u003e同步发送+重试机制+多个master节点\u003c/strong\u003e，尽可能减小消息丢失的可能性。\u003c/li\u003e\n\u003cli\u003econsumer端要保证消费消息的可靠性，主要通过\u003cstrong\u003eAt least Once+消费重试机制\u003c/strong\u003e保证。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eRabbitMQ\u003c/h2\u003e\n\u003cp\u003eRabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP，SMTP，STOMP。它比较重量级，更适合企业级的开发。\u003c/p\u003e\n\u003ch2\u003eRedis\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e使用Redis做队列有局限性，当数据大小超过了10K，Redis就慢的无法忍受。\u003c/li\u003e\n\u003cli\u003eRedis做队列没有ack机制保障。\u003c/li\u003e\n\u003cli\u003eRedis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用 rpush/lpush 操作入队列，使用 lpop / rpop 来出队列。\u003c/li\u003e\n\u003cli\u003e如果redis的队列空了，客户端会陷入 pop 的死循环。不停地 pop 但没有数据，这就是浪费生命的空轮询。空轮询不但拉高了客户端的 CPU，redis 的 QPS 也会被拉高。解决这个问题的办法是使用 blpop/brpop。这两个指令的前缀字符b代表的是blocking，也就是“阻塞读”。阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。消息的延迟几乎为零。用blpop/brpop替代前面的lpop/rpop。\u003c/li\u003e\n\u003c/ol\u003e\n","date":"2017-11-30T18:29:58.000Z","title":"浅谈消息队列（Kafka、RabbitMQ、RocketMQ等）","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["Vue.js"],"id":"vuejs-practice","title":"Vue.js 实践","date":"2017-12-02T15:36:09.000Z","published":true,"hideInList":false,"feature":null,"isTop":false},"nextPost":{"summary":null,"tags":["算法"],"id":"paxos-and-raft-consistency-algorithm-in-distributed-system","title":"分布式中的一致性算法：Paxos和Raft","date":"2017-11-27T12:10:17.000Z","published":true,"hideInList":false,"feature":null,"isTop":false}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"talk-about-message-queue"},"buildId":"rQGl2E3ObLYgPNk8QlWuc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
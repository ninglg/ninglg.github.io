<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Light Up The World</title><link rel="preload" href="/_next/static/css/1f99730bcd908d9b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1f99730bcd908d9b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-8cac0b4b405cede1.js" defer=""></script><script src="/_next/static/chunks/framework-7c47d0879e3fabaa.js" defer=""></script><script src="/_next/static/chunks/main-eabf4e641ff2595a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1c3b0aeaafcae3ac.js" defer=""></script><script src="/_next/static/chunks/493-7bce3a15b2a5d2a7.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-8c52a5d151f24266.js" defer=""></script><script src="/_next/static/34lywmESJ-J9QrCtAq08O/_buildManifest.js" defer=""></script><script src="/_next/static/34lywmESJ-J9QrCtAq08O/_ssgManifest.js" defer=""></script></head><body class="antialiased"><div id="__next"><div class="min-h-screen flex flex-col"><nav class="bg-gray-50 text-gray-700 py-4 shadow-md"><div class="flex justify-between items-center max-w-7xl mx-auto px-4"><a class="text-2xl font-bold bg-gradient-to-r from-blue-600 to-blue-900 bg-clip-text text-transparent" href="/">Light Ning</a><div class="flex gap-6"><a class="text-gray-700 font-medium transition-all duration-200 px-2 py-1 rounded hover:bg-gray-100 hover:text-blue-600" href="/">首页</a><a class="text-gray-700 font-medium transition-all duration-200 px-2 py-1 rounded hover:bg-gray-100 hover:text-blue-600" href="/about">关于</a></div></div></nav><main class="flex-1 py-8 max-w-5xl mx-auto w-full"><article class="bg-white rounded-lg p-8 shadow-sm"><h1 class="text-3xl font-bold text-gray-700 mb-2 text-center">MySQL的几种日志</h1><time class="block text-sm text-gray-600 mb-8 text-center">2015-08-11</time><div class="prose max-w-none text-gray-700 markdown"><p>每一个操作在真正写入数据库之前，都会先写入日志。MySQL的日志主要包括 错误日志、查询日志、慢查询日志、事务日志、二进制日志 等几大类。</p>
<h1>二进制日志binlog</h1>
<ol>
<li>binlog记录写入性操作（不包含查询）信息</li>
<li>以二进制形式保存在磁盘中</li>
<li>binlog是由Server层进行记录的，使用任何存储引擎的MySQL数据库均会记录binlog日志</li>
<li>binlog是以追加的方式进行写入的</li>
<li>可以通过设置max_binlog_size参数来设置每个binlog文件的大小</li>
<li>binlog的三个主要使用场景：（1）主从复制（2）数据恢复（3）信息审计</li>
<li>对于InnoDB存储引擎来说，只有事务提交时才会记录binlog</li>
<li>binlog的刷盘时机，通过sync_binlog参数来进行控制</li>
<li>binlog的日志三种格式：statement、row（默认）和mixed，通过binlog-format参数指定。statement格式会记录修改sql语句， row格式会记录行的数据内容变更，记两条，更新前和更新后都有。</li>
</ol>
<h1>事务日志redo log和undo log</h1>
<h2>redo log</h2>
<ol>
<li>redo log包含两部分，一个是内存中的日志缓冲（redo log buffer，临时的），另一个是磁盘上的日志文件（redo log file，持久的）</li>
<li>mysql每执行一条DML语句，会先将记录写入redo log buffer，后续某个时间点再一次性将多个操作记录写到redo log file。这种先写日志再写磁盘的技术，就是MySQL里经常说到的WAL（Write-Ahead Logging）技术</li>
<li>redo log buffer写入redo log file实际上是先写入OS Buffer，然后再通过系统调用fsync()将其刷到redo log file中</li>
<li>mysql支持3种将redo log buffer写入redo log file的时机，可以通过innodb_flush_log_at_trx_commit参数进行配置</li>
<li>redo log实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录redo log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的redo Log按语句的执行顺序，依次交替的记录在一起。</li>
<li>只依靠binlog是没有crash-safe能力的，只有redo log也不行。因为redo log是InnoDB特有的，且日志上的记录落盘后会被覆盖掉。因此需要binlog和redo log二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失</li>
<li>如果数据库崩溃或者宕机，那么当系统重启进行恢复时，可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务可以继续提交，也可以选择回滚，这基于恢复的策略而定。</li>
<li>redo log是innodb独有的，binlog是所有引擎都可以使用的</li>
<li>redo log是循环写的，空间会用完，binlog是可以追加写的，不会覆盖之前的日志信息</li>
<li>binlog和redo log必须保持一致，不允许出现binlog有记录但redo log没有的情况，反之亦然</li>
</ol>
<p>##undo log</p>
<ol>
<li>数据库事务的原子性保证，底层就是通过undo log实现的，主要用作回滚</li>
<li>undo log主要记录了数据的逻辑变化。比如一条INSERT语句，对应一条DELETE的undo log；对于每个UPDATE语句，对应一条相反的UPDATE的undo log。这样在发生错误时，就能回滚到事务之前的数据状态</li>
<li>undo log也是MVCC（多版本并发控制）实现的关键</li>
<li>Innodb通过force log at commit机制实现事务的持久性。即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。为了确保每次日志都能写入到事务日志文件中，在每次将log buffer中的日志写入日志文件的过程中都会调用一次操作系统的fsync操作（fsync函数同步内存中所有已修改的文件数据到储存设备）</li>
<li>单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。</li>
<li>redo log保证的是事务的持久性和一致性，而undo log则保证了事务的原子性</li>
</ol>
</div><div class="flex flex-wrap gap-2 mt-8"><span class="bg-gray-100 text-gray-700 text-sm px-2 py-1 rounded-full">MySQL</span></div></article><div class="mt-12 border-t border-gray-200 pt-8 flex justify-between"><div class="text-gray-600 text-sm flex flex-col items-start"><span class="text-sm text-gray-500">上一篇</span><a class="text-black hover:bg-gray-200 text-base mt-1 font-bold" href="/posts/system-monitor-things">关于系统监控的一些事</a></div><div class="ml-auto text-gray-600 text-sm flex flex-col items-end"><span class="text-sm text-gray-500">下一篇</span><a class="text-black hover:bg-gray-200 text-base mt-1 font-bold" href="/posts/etcd-intro-and-usage">Etcd介绍和使用</a></div></div></main><footer class="text-center bg-gray-50 text-gray-700 py-4 shadow-md mt-8"><p>Copyright © <!-- -->2025<!-- --> <!-- -->Light Ning<!-- -->. All rights reserved.</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"summary":null,"tags":["MySQL"],"id":"mysql-binlog-redolog-undolog","contentHtml":"\u003cp\u003e每一个操作在真正写入数据库之前，都会先写入日志。MySQL的日志主要包括 错误日志、查询日志、慢查询日志、事务日志、二进制日志 等几大类。\u003c/p\u003e\n\u003ch1\u003e二进制日志binlog\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003ebinlog记录写入性操作（不包含查询）信息\u003c/li\u003e\n\u003cli\u003e以二进制形式保存在磁盘中\u003c/li\u003e\n\u003cli\u003ebinlog是由Server层进行记录的，使用任何存储引擎的MySQL数据库均会记录binlog日志\u003c/li\u003e\n\u003cli\u003ebinlog是以追加的方式进行写入的\u003c/li\u003e\n\u003cli\u003e可以通过设置max_binlog_size参数来设置每个binlog文件的大小\u003c/li\u003e\n\u003cli\u003ebinlog的三个主要使用场景：（1）主从复制（2）数据恢复（3）信息审计\u003c/li\u003e\n\u003cli\u003e对于InnoDB存储引擎来说，只有事务提交时才会记录binlog\u003c/li\u003e\n\u003cli\u003ebinlog的刷盘时机，通过sync_binlog参数来进行控制\u003c/li\u003e\n\u003cli\u003ebinlog的日志三种格式：statement、row（默认）和mixed，通过binlog-format参数指定。statement格式会记录修改sql语句， row格式会记录行的数据内容变更，记两条，更新前和更新后都有。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1\u003e事务日志redo log和undo log\u003c/h1\u003e\n\u003ch2\u003eredo log\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eredo log包含两部分，一个是内存中的日志缓冲（redo log buffer，临时的），另一个是磁盘上的日志文件（redo log file，持久的）\u003c/li\u003e\n\u003cli\u003emysql每执行一条DML语句，会先将记录写入redo log buffer，后续某个时间点再一次性将多个操作记录写到redo log file。这种先写日志再写磁盘的技术，就是MySQL里经常说到的WAL（Write-Ahead Logging）技术\u003c/li\u003e\n\u003cli\u003eredo log buffer写入redo log file实际上是先写入OS Buffer，然后再通过系统调用fsync()将其刷到redo log file中\u003c/li\u003e\n\u003cli\u003emysql支持3种将redo log buffer写入redo log file的时机，可以通过innodb_flush_log_at_trx_commit参数进行配置\u003c/li\u003e\n\u003cli\u003eredo log实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录redo log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的redo Log按语句的执行顺序，依次交替的记录在一起。\u003c/li\u003e\n\u003cli\u003e只依靠binlog是没有crash-safe能力的，只有redo log也不行。因为redo log是InnoDB特有的，且日志上的记录落盘后会被覆盖掉。因此需要binlog和redo log二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失\u003c/li\u003e\n\u003cli\u003e如果数据库崩溃或者宕机，那么当系统重启进行恢复时，可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务可以继续提交，也可以选择回滚，这基于恢复的策略而定。\u003c/li\u003e\n\u003cli\u003eredo log是innodb独有的，binlog是所有引擎都可以使用的\u003c/li\u003e\n\u003cli\u003eredo log是循环写的，空间会用完，binlog是可以追加写的，不会覆盖之前的日志信息\u003c/li\u003e\n\u003cli\u003ebinlog和redo log必须保持一致，不允许出现binlog有记录但redo log没有的情况，反之亦然\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e##undo log\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e数据库事务的原子性保证，底层就是通过undo log实现的，主要用作回滚\u003c/li\u003e\n\u003cli\u003eundo log主要记录了数据的逻辑变化。比如一条INSERT语句，对应一条DELETE的undo log；对于每个UPDATE语句，对应一条相反的UPDATE的undo log。这样在发生错误时，就能回滚到事务之前的数据状态\u003c/li\u003e\n\u003cli\u003eundo log也是MVCC（多版本并发控制）实现的关键\u003c/li\u003e\n\u003cli\u003eInnodb通过force log at commit机制实现事务的持久性。即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。为了确保每次日志都能写入到事务日志文件中，在每次将log buffer中的日志写入日志文件的过程中都会调用一次操作系统的fsync操作（fsync函数同步内存中所有已修改的文件数据到储存设备）\u003c/li\u003e\n\u003cli\u003e单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。\u003c/li\u003e\n\u003cli\u003eredo log保证的是事务的持久性和一致性，而undo log则保证了事务的原子性\u003c/li\u003e\n\u003c/ol\u003e\n","date":"2015-08-11","title":"MySQL的几种日志"},"prevPost":{"summary":null,"tags":["系统设计","Linux"],"id":"system-monitor-things","title":"关于系统监控的一些事","date":"2015-09-11"},"nextPost":{"summary":null,"tags":["微服务","分布式系统"],"id":"etcd-intro-and-usage","title":"Etcd介绍和使用","date":"2015-07-22"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"mysql-binlog-redolog-undolog"},"buildId":"34lywmESJ-J9QrCtAq08O","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Light Up The World</title><link rel="preload" href="/_next/static/css/1f99730bcd908d9b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1f99730bcd908d9b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-8cac0b4b405cede1.js" defer=""></script><script src="/_next/static/chunks/framework-7c47d0879e3fabaa.js" defer=""></script><script src="/_next/static/chunks/main-eabf4e641ff2595a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1c3b0aeaafcae3ac.js" defer=""></script><script src="/_next/static/chunks/493-7bce3a15b2a5d2a7.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-8c52a5d151f24266.js" defer=""></script><script src="/_next/static/34lywmESJ-J9QrCtAq08O/_buildManifest.js" defer=""></script><script src="/_next/static/34lywmESJ-J9QrCtAq08O/_ssgManifest.js" defer=""></script></head><body class="antialiased"><div id="__next"><div class="min-h-screen flex flex-col"><nav class="bg-gray-50 text-gray-700 py-4 shadow-md"><div class="flex justify-between items-center max-w-7xl mx-auto px-4"><a class="text-2xl font-bold bg-gradient-to-r from-blue-600 to-blue-900 bg-clip-text text-transparent" href="/">Light Ning</a><div class="flex gap-6"><a class="text-gray-700 font-medium transition-all duration-200 px-2 py-1 rounded hover:bg-gray-100 hover:text-blue-600" href="/">首页</a><a class="text-gray-700 font-medium transition-all duration-200 px-2 py-1 rounded hover:bg-gray-100 hover:text-blue-600" href="/about">关于</a></div></div></nav><main class="flex-1 py-8 max-w-5xl mx-auto w-full"><article class="bg-white rounded-lg p-8 shadow-sm"><h1 class="text-3xl font-bold text-gray-700 mb-2 text-center">Go程序性能分析工具</h1><time class="block text-sm text-gray-600 mb-8 text-center">2016-05-09</time><div class="prose max-w-none text-gray-700 markdown"><h1>常用命令和工具</h1>
<pre><code class="language-txt">pprof
go tool [xxx]
go test
delve
go race
gdb
</code></pre>
<h1>程序编译时的参数传递（gcflags和ldflags）</h1>
<h2>gcflags</h2>
<pre><code class="language-txt">go build -gcflags '-N -m -l' main.go //可使用go tool compile --help查看可用参数及含义。
比如-N禁用编译优化，-l禁止内联，-m打印编译优化策略（包括逃逸情况和函数是否内联，以及变量分配在堆或栈），-S是打印汇编。

如果只在编译特定包时需要传递参数，格式应遵守“包名=参数列表”，如go build -gcflags='log=-N -l' main.go

开启逃逸分析日志很简单，只要在编译的时候加上-gcflags '-m'，另外为了不让编译时自动内联函数，一般也会加-l参数，最终成为-gcflags '-m -l'。即执行如下命令：
$ go build -gcflags '-m -l' main.go
</code></pre>
<h2>ldflags</h2>
<pre><code class="language-txt">go build用 -ldflags 给go链接器传入参数，实际是给go tool link的参数，可以用go tool link --help查看可用的参数。

常用 -X 来指定版本号等编译时才决定的参数值。例如代码中定义var buildVer string，然后在编译时用go build -ldflags "-X main.buildVer=1.0" 来赋值。注意 -X 只能给string类型变量赋值。
</code></pre>
<blockquote>
<p>传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。
一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能。</p>
</blockquote>
<h2>go build -x</h2>
<p>列出了go build触发的所有命令。
比如工具链、跨平台编译、传入外部编译器的flags、链接器等，可使用 -x 来查看所有的触发。</p>
<h1>竞争检测</h1>
<p>使用</p>
<blockquote>
<p>go run -race main.go
或
go build -race main.go
来进行竞争检测。</p>
</blockquote>
<h1>GC日志和调度器事件</h1>
<ol>
<li>执行前添加系统环境变量 GODEBUG='gctrace=1' 来跟踪打印垃圾回收器信息</li>
<li>在代码中使用 runtime.ReadMemStats 来获取程序当前内存的使用情况</li>
<li>使用pprof工具</li>
</ol>
<blockquote>
<p>GODEBUG=gctrace=1 go run main.go  //跟踪打印垃圾回收器信息。Go程序会每隔一段时间打印一些gc信息。
GODEBUG=schedtrace=1 go run main.go //参数 schedtrace=1 会按毫秒打印 Go 调度器的调度事件</p>
</blockquote>
<ol start="4">
<li>字段解释</li>
</ol>
<pre><code class="language-shell">GODEBUG=gctrace=1 go run main.go
gc 1 @0.006s 1%: 0.015+0.76+0.034 ms clock, 0.24+0.45/0.67/0.011+0.55 ms cpu, 4->4->0 MB, 5 MB goal, 16 P

gc 1: 1 是垃圾回收的编号，逐步递增，一般从 1 开始
@0.006s: 自程序开始经历了多少时间
1%: 自程序启动花在 GC 上的 CPU 时间百分比, CPU 1%花在了 GC 上
0.015+0.76+0.034 ms clock: GC 各阶段的墙上时间(wall-clock)，各阶段包括STW sweep termination、concurrent mark and scan、STW mark termination
0.24+0.45/0.67/0.011+0.55 ms cpu: 各阶段的 CPU 时间。各阶段同上，其中 mark/scan 阶段又分成了assist time、background GC time和idle GC time阶段
4->4->0 MB: GC 开始时、GC 结束的 heap 大小、存活(live)的 heap 大小
5 MB goal:下一次垃圾回收的目标值
16 P: 使用的处理器的数量

程序中可以调用runtime.GC()进行强制垃圾回收。
</code></pre>
<h1>Pprof</h1>
<h2>Go语言内置了获取程序运行数据的工具，包括以下两个标准库</h2>
<blockquote>
<p>runtime/pprof：采集工具型应用运行数据进行分析
net/http/pprof：采集服务型应用运行时数据进行分析</p>
</blockquote>
<h2>工具型应用分析</h2>
<h3>CPU分析</h3>
<pre><code class="language-go">f, err := os.Create(*cpuprofile)
...
pprof.StartCPUProfile(f)
defer pprof.StopCPUProfile()
</code></pre>
<h3>内存分析</h3>
<pre><code class="language-go">f, err := os.Create(*memprofile)
pprof.WriteHeapProfile(f)
f.Close()
</code></pre>
<h2>使用net/http包时启用Pprof</h2>
<pre><code class="language-go">package main

import (
	"log"
	"net/http"
	_ "net/http/pprof"
)

func main() {
	//... do something

	log.Println(http.ListenAndServe("localhost:8090", nil))
}
</code></pre>
<h2>使用Gin框架时启用Pprof</h2>
<pre><code class="language-go">package main

import (
	"github.com/gin-contrib/pprof"
	"github.com/gin-gonic/gin"
)

func main() {
	app := gin.Default()

	pprof.Register(app)

	app.Run(":8090")
}
</code></pre>
<h2>访问web页获取分析结果（<a href="http://127.0.0.1:8090/debug/pprof%EF%BC%8C%E9%80%82%E5%90%88http%E6%9C%8D%E5%8A%A1%EF%BC%89">http://127.0.0.1:8090/debug/pprof，适合http服务）</a></h2>
<pre><code class="language-txt">/debug/pprof/

Types of profiles available:
Count	Profile
3	allocs
0	block    //goroutine的阻塞信息
0	cmdline
4	goroutine    //此项可排查是否创建了大量的 goroutine
3	heap    //堆内存的分配信息
0	mutex    //锁的信息
0	profile
7	threadcreate    //线程信息
0	trace
full goroutine stack dump  //此项可排查是否有 goroutine 运行时间过长
Profile Descriptions:

allocs: A sampling of all past memory allocations
block: Stack traces that led to blocking on synchronization primitives
cmdline: The command line invocation of the current program
goroutine: Stack traces of all current goroutines
heap: A sampling of memory allocations of live objects. You can specify the gc GET parameter to run GC before taking the heap sample.
mutex: Stack traces of holders of contended mutexes
profile: CPU profile. You can specify the duration in the seconds GET parameter. After you get the profile file, use the go tool pprof command to investigate the profile.
threadcreate: Stack traces that led to the creation of new OS threads
trace: A trace of execution of the current program. You can specify the duration in the seconds GET parameter. After you get the trace file, use the go tool trace command to investigate the trace.
</code></pre>
<h2>pprof 支持四种类型的分析</h2>
<p>pprof开启后，每隔一段时间（10ms）就会收集当前的堆栈信息，获取各个函数占用的CPU以及内存资源，然后通过对这些采样数据进行分析，形成一个性能分析报告。</p>
<pre><code class="language-txt">CPU Profile：CPU 分析，采样消耗 cpu 的调用，这个一般用来定位排查程序里耗费计算资源的地方

Memory Profile（Heap Profile）：内存分析，一般用来排查内存占用，内存泄露等问题。堆内存分配情况的记录。默认每分配512K字节时取样一次。

Block Profile：阻塞分析，报告导致阻塞的同步原语的情况，可以用来分析和查找锁的性能瓶颈。Goroutine阻塞事件的堆栈跟踪记录。默认每发生一次阻塞事件时取样一次。

Goroutine Profile ：报告goroutines的使用情况，有哪些goroutine，它们的调用关系是怎样的。活跃Goroutine的信息的记录，以及调用关系。仅在获取时取样一次。
</code></pre>
<h3>Pprof可视化</h3>
<p>在Mac上安装graphviz执行以下命令</p>
<pre><code class="language-txt">brew install graphviz
</code></pre>
<h2>以本地文件形式获取分析结果</h2>
<pre><code class="language-txt">先把信息 dump 到本地文件，然后用 go tool 去分析（生产环境通用的方式）
</code></pre>
<h1>第三方工具：debugcharts</h1>
<p>一个可以实时查看go程序内存、CPU、GC、协程等变化情况的可视化工具。启用方式跟pprof类似，都是先import引入，然后开启端口监听即可。</p>
<pre><code class="language-go">package main

import (
	_ "github.com/mkevac/debugcharts"
	"log"
	"net/http"
)

func main() {
	//... do something

	log.Println(http.ListenAndServe("localhost:8090", nil))
}
</code></pre>
<p>然后在浏览器中打开查看：</p>
<blockquote>
<p><a href="http://127.0.0.1:8090/debug/charts/">http://127.0.0.1:8090/debug/charts/</a></p>
</blockquote>
<h2>第三方工具：prometheus</h2>
<p>prometheus是grafana的插件，支持go监控的可视化。
启用方式先引入包：</p>
<pre><code class="language-go">_ "github.com/prometheus/client_golang/prometheus/promhttp"
</code></pre>
<p>然后增加路由：</p>
<pre><code class="language-go">//prometheus
http.Handle("/metrics", promhttp.Handler())
http.ListenAndServe(":8090", nil)
</code></pre>
<p>最后，通过访问 <a href="http://127.0.0.1:8090/metrics">http://127.0.0.1:8090/metrics</a> 查看采集到的指标数据。</p>
<p>** 可以通过一个端口同时开启pprof + charts + prometheus **</p>
<h1>go tool [xxx]</h1>
<p>输入 go tool 查看内置的所有[xxx]工具命令</p>
<pre><code class="language-txt">addr2line
api
asm
buildid
cgo
compile：代码汇编
cover：生成代码覆盖率
dist
doc
fix
link
nm：查看符号表（等同于系统 nm 命令）
objdump：反汇编工具，分析二进制文件（等同于系统 objdump 命令）
oldlink
pack
pprof：性能和指标分析工具
test2json
trace：采样一段时间，指标跟踪分析工具
vet
</code></pre>
<h2>go tool nm 查看符号表的命令</h2>
<p>在断点的时候，如果不知道断点的函数符号，可以用这个命令进行查询（命令处理的是二进制程序文件）。</p>
<blockquote>
<p>go tool nm ./main
输出的第一列是地址，第二列是类型，第三列是符号。</p>
</blockquote>
<pre><code class="language-txt"> 115aa00 T bufio.(*ReadWriter).Available
 115aa20 T bufio.(*ReadWriter).Discard
 115aa60 T bufio.(*ReadWriter).Flush
 115aa80 T bufio.(*ReadWriter).Peek
</code></pre>
<h2>go tool compile 汇编某个文件</h2>
<pre><code class="language-txt">go tool compile -N -l -S main.go
</code></pre>
<h2>go tool objdump 反汇编二进制的工具</h2>
<blockquote>
<p>go tool objdump main.o
go tool objdump -s DoFunc main.o  //反汇编具体函数</p>
</blockquote>
<h2>go tool pprof 性能指标分析工具</h2>
<h3>命令行分析模式</h3>
<blockquote>
<p>go tool pprof <a href="http://localhost:8090/debug/pprof/heap?second=10">http://localhost:8090/debug/pprof/heap?second=10</a> 分析heap，进入命令行模式，输入 web 即可以web方式打开（前提是安装了graphviz）。或者继续输入命令：
在命令行输入top默认查看程序中占用内存前10位的函数
在命令行输入top 3可以查看程序中占用内存前3位的函数
同样，如果采集的是cpu使用top命令可以看占用cpu的函数</p>
</blockquote>
<p>输入top后显示的最后一列为函数名称，其他各项内容意义如下：</p>
<pre><code class="language-txt">flat：当前函数占用CPU的耗时
flat%：当前函数占用CPU的耗时百分比
sum%：函数占用CPU的累积耗时百分比
cum：当前函数+调用的子函数 占用CPU总耗时
cum%：当前函数+调用的子函数 占用CPU总耗时百分比
</code></pre>
<blockquote>
<p>可以在命令行输入 list+函数名 命令查看具体的函数分析
可以在命令行输入 pdf 生成可视化的pdf文件
可以在命令行输入 help 提供所有pprof支持的命令说明</p>
</blockquote>
<h3>web分析模式</h3>
<blockquote>
<p>go tool pprof -http=:1234 <a href="http://localhost:8090/debug/pprof/heap?second=10">http://localhost:8090/debug/pprof/heap?second=10</a> 会直接以web方式打开。或者：
<a href="http://localhost:1234/ui/">http://localhost:1234/ui/</a> 也可以直接打开，从中可以直接筛选查看火焰图（Flame Graph）。
-http 表示使用交互式web接口查看获取的性能信息，指定可用的端口即可。
debug/pprof/需要查看的指标（allocs,block,goroutine,heap等）
火焰图从上往下是方法的调用栈，长度代表使用的cpu时长。</p>
</blockquote>
<h3>其他的一些go tool pprof 分析命令</h3>
<blockquote>
<p>go tool pprof -http=:1234 <a href="http://localhost:8090/debug/pprof/goroutine?second=10">http://localhost:8090/debug/pprof/goroutine?second=10</a>
go tool pprof --seconds 10 <a href="http://localhost:8090/debug/pprof/goroutine">http://localhost:8090/debug/pprof/goroutine</a></p>
</blockquote>
<blockquote>
<p>如果应用比较复杂，生成的调用图特别大，看起来很乱，有两个办法可以优化：
使用 web [funcName] 的方式，只打印和某个函数相关的内容
运行 go tool pprof 命令时加上 --nodefration 参数，可以忽略内存使用较少的函数，比如--nodefration=0.05表示如果调用的子函数使用的 CPU、memory 不超过 5%，就忽略它，不要显示在图片中</p>
</blockquote>
<h1>go test 单元测试</h1>
<blockquote>
<p>_test.go 结尾的文件认为是测试文件
本质上，golang 跑单测是先编译 *_test.go 文件，编译成二进制后，再运行这个二进制文件</p>
</blockquote>
<pre><code class="language-txt">go test .    //直接在本目录中运行go test
go test -run=TestPutAndGetKeyValue    //指定运行函数
go test -v    //提供详细的测试输出，打印测试名称、状态（通过或者失败）、耗时、测试用例的日志等

go test -race    //测试时支持对竞争进行检测和报告
go test -coverprofile=c.out &#x26;&#x26; go tool cover -html=c.out    //输出一个覆盖信息结果并可在浏览器上可视化观看
</code></pre>
<h2>编译生成单元测试可执行文件</h2>
<pre><code class="language-txt">// 先编译出 .test 文件
$ go test -c 
// 指定跑某一个文件
$ ./raftexample.test -test.timeout=10m0s -test.v=true -test.run=TestPutAndGetKeyValue
</code></pre>
<h2>统计代码覆盖率</h2>
<ol>
<li>加一个 -coverprofile 的参数，声明在跑单测的时候，记录代码覆盖率</li>
</ol>
<blockquote>
<p>go test -coverprofile=coverage.out</p>
</blockquote>
<ol start="2">
<li>使用 go tool cover 命令分析，得出覆盖率报告</li>
</ol>
<blockquote>
<p>go tool cover -func=coverage.out</p>
</blockquote>
<h1>Delve</h1>
<blockquote>
<p>delve 当前是最友好的 golang 调试程序，ide 调试其实也是调用 dlv 而已，比如 goland
安装dlv：
go get -u github.com/go-delve/delve/cmd/dlv
检查安装版本信息：
dlv version</p>
</blockquote>
<h2>把程序加载进 Delve 调试器的两种方式（事先需要有go.mod）</h2>
<h3>加载源码进行调试</h3>
<blockquote>
<p>dlv debug</p>
</blockquote>
<ol>
<li>执行 dlv debug 进入命令行模式，此时同目录下会自动生成一个 __debug_bin 文件。这个文件是由源码编译生成的，并会自动加载进调试器。</li>
<li>Delve 期望的是从单个程序或项目中构建出单个二进制文件，如果目录中有多个源文件且每个文件都有自己的主函数， Delve 则可能抛出错误。此种情况下应该使用下面第二种方式，加载二进制文件进行调试。</li>
</ol>
<h3>加载二进制文件进行调试</h3>
<blockquote>
<p>dlv exec ./main</p>
</blockquote>
<ol>
<li>使用 dlv exec 命令将二进制文件加载进调试器。</li>
<li>在命令行模式下输入 help 查看可用命令。</li>
<li>常使用的一些命令：</li>
</ol>
<pre><code class="language-txt">b main.main     //在 main 函数处设置断点，等同于 break main.main
b func.go:5     //使用 文件名:行号 的格式来设置断点，也可以直接用行号设置断点
bp                  //查看设置的断点，等同于 breakpoints
clear [断点标号如2]          //清除单个断点
clearall            //清除所有断点
on                  //设置一段命令，当断点命中的时候
c                   //继续运行程序，运行到断点处中止，等同于 continue
n                   //单步调试下一行源码，等同于 next。默认情况下，Delve不会更深入地调试函数调用。
s                   //单步调试下一个函数，等同于 step
step-instruction    //单步调试某个汇编指令
stack              //打印当前堆栈的内容信息，可以看到0、1、2、3...等栈位置的函数
frame 0           //实现帧之间的跳转，可以使用 stack 输出的位置序号
args                //打印出命令行传给函数的参数
disassemble    //查看编译器生成的汇编语言指令
stepout           //跳回到函数被调用的地方
print [var_name]         //打印变量的值
whatis [var_name]        //打印变量的类型
locals                //打印函数内的所有局部变量
regs                    //打印寄存器的信息
x                       //等同于examinemem，这个是解析内存用的，和 gdb 的 x 命令一样
set                     //set赋值
vars                    //打印全局变量（包变量）
whatis                  //打印类型信息
r                       //重新启动并调试执行程序，等同于restart
call                    //整个程序执行
quit                //退出调试器

协程相关
goroutine (alias: gr)       //打印某个特定协程的信息
goroutines (alias: grs)     //列举所有的协程
goroutines -t                   //展开所有协程详细信息
thread (alias: tr)              //切换到某个线程
threads                         //打印所有的线程信息

栈相关
deferred                    //在 defer 函数上下文里执行命令
down                        //上堆栈
frame                       //跳到某个具体的堆栈
stack (alias: bt)          //打印堆栈信息
up                           //下堆栈

其他命令
config                      //配置变更
disassemble (alias: disass)     //反汇编
funcs                           //打印所有函数符号
libraries                       //打印所有加载的动态库
list (alias: ls | l)            //显示源码
source                      //加载命令
sources                     //打印源码
types                       //打印所有类型信息
</code></pre>
<h2>dlv的其它命令</h2>
<pre><code class="language-txt">dlv debug：使用dlv debug可以在main函数文件所在目录直接对main函数进行调试，也可以在根目录以指定包路径的方式对main函数进行调试
dlv exec：使用dlv exec可以对编译好的二进制进行调试
dlv test：使用dlv test可以对test包进行调试
dlv attach：使用dlv attach可以附加到一个已在运行的进程进行调试
dlv connect：使用dlv connect可以连接到调试服务器进行调试
dlv trace：使用dlv trace可以追踪程序
</code></pre>
<h1>go race</h1>
<ol>
<li>Go 语言提供了 race 检测（Go race detector）来进行竞争分析和发现</li>
<li>go run -race main.go 是运行时检测，并不是编译时。且使用 race 时存在明显的性能开销，因此不要在生产环境中使用这个。</li>
</ol>
<h1>GDB</h1>
<h2>gdb当前只支持6个命令</h2>
<ol>
<li>3个 cmd 命令</li>
</ol>
<pre><code class="language-txt">info goroutines         //打印所有的goroutines
goroutine ${id} bt      //打印一个goroutine的堆栈
iface                       //打印静态或者动态的接口类型
</code></pre>
<ol start="2">
<li>3个函数</li>
</ol>
<pre><code class="language-txt">len                         //打印string，slices，map，channels 这四种类型的长度
cap                         //打印slices，channels 这两种类型的cap
dtype                       //强制转换接口到动态类型。
</code></pre>
<blockquote>
<p>gdb 有一个功能是无法替代的，就是 gcore 的功能</p>
</blockquote>
<h1>GOGC 环境变量</h1>
<ol>
<li>Go垃圾回收提供了一个参数GOGC。</li>
<li>GOGC代表了占用中的内存增长比率，达到该比率时应当触发1次GC，该参数可以通过环境变量进行设置。。</li>
<li>GOGC参数取值范围为0~100，其默认值是100，单位是百分比。
假如当前heap占用内存为4MB，GOGC = 75，则 4*(1+75%)=7MB，即heap占用内存大小达到7MB时会触发1轮GC。</li>
<li>GOGC还有2个特殊值：
“off” : 代表关闭GC
0 : 代表持续进行垃圾回收，只用于调试。</li>
</ol>
<h1>runtime.MemStats</h1>
<p>通过runtime.MemStats可以实时的获取 Go 运行时的内存统计信息，这个数据结构包含很多的字段。</p>
<pre><code class="language-go">type MemStats struct {
        // 已分配的对象的字节数.
        //
        // 和HeapAlloc相同.
        Alloc uint64

        // 分配的字节数累积之和.
        //
        // 所以对象释放的时候这个值不会减少.
        TotalAlloc uint64

        // 从操作系统获得的内存总数.
        //
        // Sys是下面的XXXSys字段的数值的和, 是为堆、栈、其它内部数据保留的虚拟内存空间.
        // 注意虚拟内存空间和物理内存的区别.
        Sys uint64

        // 运行时地址查找的次数，主要用在运行时内部调试上.
        Lookups uint64

        // 堆对象分配的次数累积和.
        // 活动对象的数量等于`Mallocs - Frees`.
        Mallocs uint64

        // 释放的对象数.
        Frees uint64

        // 分配的堆对象的字节数.
        //
        // 包括所有可访问的对象以及还未被垃圾回收的不可访问的对象.
        // 所以这个值是变化的，分配对象时会增加，垃圾回收对象时会减少.
        HeapAlloc uint64

        // 从操作系统获得的堆内存大小.
        //
        // 虚拟内存空间为堆保留的大小，包括还没有被使用的.
        // HeapSys 可被估算为堆已有的最大尺寸.
        HeapSys uint64

        // HeapIdle是idle(未被使用的) span中的字节数.
        //
        // Idle span是指没有任何对象的span,这些span **可以**返还给操作系统，或者它们可以被重用,
        // 或者它们可以用做栈内存.
        //
        // HeapIdle 减去 HeapReleased 的值可以当作"可以返回到操作系统但由运行时保留的内存量".
        // 以便在不向操作系统请求更多内存的情况下增加堆，也就是运行时的"小金库".
        //
        // 如果这个差值明显比堆的大小大很多，说明最近在活动堆的上有一次尖峰.
        HeapIdle uint64

        // 正在使用的span的字节大小.
        //
        // 正在使用的span是值它至少包含一个对象在其中.
        // HeapInuse 减去 HeapAlloc的值是为特殊大小保留的内存，但是当前还没有被使用.
        HeapInuse uint64

        // HeapReleased 是返还给操作系统的物理内存的字节数.
        //
        // 它统计了从idle span中返还给操作系统，没有被重新获取的内存大小.
        HeapReleased uint64


        // HeapObjects 实时统计的分配的堆对象的数量,类似HeapAlloc.
        HeapObjects uint64

        // 栈span使用的字节数。
        // 正在使用的栈span是指至少有一个栈在其中.
        //
        // 注意并没有idle的栈span,因为未使用的栈span会被返还给堆(HeapIdle).
        StackInuse uint64

        // 从操作系统取得的栈内存大小.
        // 等于StackInuse 再加上为操作系统线程栈获得的内存.
        StackSys uint64

        // 分配的mspan数据结构的字节数.
        MSpanInuse uint64

        // 从操作系统为mspan获取的内存字节数.
        MSpanSys uint64

        // 分配的mcache数据结构的字节数.
        MCacheInuse uint64

        // 从操作系统为mcache获取的内存字节数.
        MCacheSys uint64

        // 在profiling bucket hash tables中的内存字节数.
        BuckHashSys uint64

        // 垃圾回收元数据使用的内存字节数.
        GCSys uint64 // Go 1.2

        // off-heap的杂项内存字节数.
        OtherSys uint64 // Go 1.2

        // 下一次垃圾回收的目标大小，保证 HeapAlloc ≤ NextGC.
        // 基于当前可访问的数据和GOGC的值计算而得.
        NextGC uint64

        // 上一次垃圾回收的时间.
        LastGC uint64

        // 自程序开始 STW 暂停的累积纳秒数.
        // STW的时候除了垃圾回收器之外所有的goroutine都会暂停.
        PauseTotalNs uint64

        // 一个循环buffer，用来记录最近的256个GC STW的暂停时间.
        PauseNs [256]uint64

        // 最近256个GC暂停截止的时间.
        PauseEnd [256]uint64 // Go 1.4

        // GC的总次数.
        NumGC uint32

        // 强制GC的次数.
        NumForcedGC uint32 // Go 1.8

        // 自程序启动后由GC占用的CPU可用时间，数值在 0 到 1 之间.
        // 0代表GC没有消耗程序的CPU. GOMAXPROCS * 程序运行时间等于程序的CPU可用时间.
        GCCPUFraction float64 // Go 1.5

        // 是否允许GC.
        EnableGC bool

        // 未使用.
        DebugGC bool

        // 按照大小进行的内存分配的统计,具体可以看Go内存分配的文章介绍.
        BySize [61]struct {
                // Size is the maximum byte size of an object in this
                // size class.
                Size uint32

                // Mallocs is the cumulative count of heap objects
                // allocated in this size class. The cumulative bytes
                // of allocation is Size*Mallocs. The number of live
                // objects in this size class is Mallocs - Frees.
                Mallocs uint64

                // Frees is the cumulative count of heap objects freed
                // in this size class.
                Frees uint64
        }
}
</code></pre>
<h1>runtime.SetGCPercent</h1>
<p>可以通过设置runtime.SetGCPercent参数来调整GOGC垃圾回收的目标百分比。
当这次新分配的数据和上一次垃圾回收后存活数据之比达到这个数值之后就会触发一次垃圾回收。
GOGC的默认值是 100。设置GOGC=off会禁止垃圾回收。</p>
</div><div class="flex flex-wrap gap-2 mt-8"><span class="bg-gray-100 text-gray-700 text-sm px-2 py-1 rounded-full">Golang</span></div></article><div class="mt-12 border-t border-gray-200 pt-8 flex justify-between"><div class="text-gray-600 text-sm flex flex-col items-start"><span class="text-sm text-gray-500">上一篇</span><a class="text-black hover:bg-gray-200 text-base mt-1 font-bold" href="/posts/golang-strings">Go字符串处理</a></div><div class="ml-auto text-gray-600 text-sm flex flex-col items-end"><span class="text-sm text-gray-500">下一篇</span><a class="text-black hover:bg-gray-200 text-base mt-1 font-bold" href="/posts/golang-concurrent-programming-practices">Go并发编程实践</a></div></div></main><footer class="text-center bg-gray-50 text-gray-700 py-4 shadow-md mt-8"><p>Copyright © <!-- -->2025<!-- --> <!-- -->Light Ning<!-- -->. All rights reserved.</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"summary":null,"tags":["Golang"],"id":"golang-program-performance-analysis-tools","contentHtml":"\u003ch1\u003e常用命令和工具\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003epprof\ngo tool [xxx]\ngo test\ndelve\ngo race\ngdb\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e程序编译时的参数传递（gcflags和ldflags）\u003c/h1\u003e\n\u003ch2\u003egcflags\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003ego build -gcflags '-N -m -l' main.go //可使用go tool compile --help查看可用参数及含义。\n比如-N禁用编译优化，-l禁止内联，-m打印编译优化策略（包括逃逸情况和函数是否内联，以及变量分配在堆或栈），-S是打印汇编。\n\n如果只在编译特定包时需要传递参数，格式应遵守“包名=参数列表”，如go build -gcflags='log=-N -l' main.go\n\n开启逃逸分析日志很简单，只要在编译的时候加上-gcflags '-m'，另外为了不让编译时自动内联函数，一般也会加-l参数，最终成为-gcflags '-m -l'。即执行如下命令：\n$ go build -gcflags '-m -l' main.go\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eldflags\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003ego build用 -ldflags 给go链接器传入参数，实际是给go tool link的参数，可以用go tool link --help查看可用的参数。\n\n常用 -X 来指定版本号等编译时才决定的参数值。例如代码中定义var buildVer string，然后在编译时用go build -ldflags \"-X main.buildVer=1.0\" 来赋值。注意 -X 只能给string类型变量赋值。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。\n一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ego build -x\u003c/h2\u003e\n\u003cp\u003e列出了go build触发的所有命令。\n比如工具链、跨平台编译、传入外部编译器的flags、链接器等，可使用 -x 来查看所有的触发。\u003c/p\u003e\n\u003ch1\u003e竞争检测\u003c/h1\u003e\n\u003cp\u003e使用\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ego run -race main.go\n或\ngo build -race main.go\n来进行竞争检测。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003eGC日志和调度器事件\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e执行前添加系统环境变量 GODEBUG='gctrace=1' 来跟踪打印垃圾回收器信息\u003c/li\u003e\n\u003cli\u003e在代码中使用 runtime.ReadMemStats 来获取程序当前内存的使用情况\u003c/li\u003e\n\u003cli\u003e使用pprof工具\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGODEBUG=gctrace=1 go run main.go  //跟踪打印垃圾回收器信息。Go程序会每隔一段时间打印一些gc信息。\nGODEBUG=schedtrace=1 go run main.go //参数 schedtrace=1 会按毫秒打印 Go 调度器的调度事件\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e字段解释\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003eGODEBUG=gctrace=1 go run main.go\ngc 1 @0.006s 1%: 0.015+0.76+0.034 ms clock, 0.24+0.45/0.67/0.011+0.55 ms cpu, 4-\u003e4-\u003e0 MB, 5 MB goal, 16 P\n\ngc 1: 1 是垃圾回收的编号，逐步递增，一般从 1 开始\n@0.006s: 自程序开始经历了多少时间\n1%: 自程序启动花在 GC 上的 CPU 时间百分比, CPU 1%花在了 GC 上\n0.015+0.76+0.034 ms clock: GC 各阶段的墙上时间(wall-clock)，各阶段包括STW sweep termination、concurrent mark and scan、STW mark termination\n0.24+0.45/0.67/0.011+0.55 ms cpu: 各阶段的 CPU 时间。各阶段同上，其中 mark/scan 阶段又分成了assist time、background GC time和idle GC time阶段\n4-\u003e4-\u003e0 MB: GC 开始时、GC 结束的 heap 大小、存活(live)的 heap 大小\n5 MB goal:下一次垃圾回收的目标值\n16 P: 使用的处理器的数量\n\n程序中可以调用runtime.GC()进行强制垃圾回收。\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003ePprof\u003c/h1\u003e\n\u003ch2\u003eGo语言内置了获取程序运行数据的工具，包括以下两个标准库\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eruntime/pprof：采集工具型应用运行数据进行分析\nnet/http/pprof：采集服务型应用运行时数据进行分析\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e工具型应用分析\u003c/h2\u003e\n\u003ch3\u003eCPU分析\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003ef, err := os.Create(*cpuprofile)\n...\npprof.StartCPUProfile(f)\ndefer pprof.StopCPUProfile()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e内存分析\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003ef, err := os.Create(*memprofile)\npprof.WriteHeapProfile(f)\nf.Close()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e使用net/http包时启用Pprof\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t_ \"net/http/pprof\"\n)\n\nfunc main() {\n\t//... do something\n\n\tlog.Println(http.ListenAndServe(\"localhost:8090\", nil))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e使用Gin框架时启用Pprof\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport (\n\t\"github.com/gin-contrib/pprof\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tapp := gin.Default()\n\n\tpprof.Register(app)\n\n\tapp.Run(\":8090\")\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e访问web页获取分析结果（\u003ca href=\"http://127.0.0.1:8090/debug/pprof%EF%BC%8C%E9%80%82%E5%90%88http%E6%9C%8D%E5%8A%A1%EF%BC%89\"\u003ehttp://127.0.0.1:8090/debug/pprof，适合http服务）\u003c/a\u003e\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003e/debug/pprof/\n\nTypes of profiles available:\nCount\tProfile\n3\tallocs\n0\tblock    //goroutine的阻塞信息\n0\tcmdline\n4\tgoroutine    //此项可排查是否创建了大量的 goroutine\n3\theap    //堆内存的分配信息\n0\tmutex    //锁的信息\n0\tprofile\n7\tthreadcreate    //线程信息\n0\ttrace\nfull goroutine stack dump  //此项可排查是否有 goroutine 运行时间过长\nProfile Descriptions:\n\nallocs: A sampling of all past memory allocations\nblock: Stack traces that led to blocking on synchronization primitives\ncmdline: The command line invocation of the current program\ngoroutine: Stack traces of all current goroutines\nheap: A sampling of memory allocations of live objects. You can specify the gc GET parameter to run GC before taking the heap sample.\nmutex: Stack traces of holders of contended mutexes\nprofile: CPU profile. You can specify the duration in the seconds GET parameter. After you get the profile file, use the go tool pprof command to investigate the profile.\nthreadcreate: Stack traces that led to the creation of new OS threads\ntrace: A trace of execution of the current program. You can specify the duration in the seconds GET parameter. After you get the trace file, use the go tool trace command to investigate the trace.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003epprof 支持四种类型的分析\u003c/h2\u003e\n\u003cp\u003epprof开启后，每隔一段时间（10ms）就会收集当前的堆栈信息，获取各个函数占用的CPU以及内存资源，然后通过对这些采样数据进行分析，形成一个性能分析报告。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003eCPU Profile：CPU 分析，采样消耗 cpu 的调用，这个一般用来定位排查程序里耗费计算资源的地方\n\nMemory Profile（Heap Profile）：内存分析，一般用来排查内存占用，内存泄露等问题。堆内存分配情况的记录。默认每分配512K字节时取样一次。\n\nBlock Profile：阻塞分析，报告导致阻塞的同步原语的情况，可以用来分析和查找锁的性能瓶颈。Goroutine阻塞事件的堆栈跟踪记录。默认每发生一次阻塞事件时取样一次。\n\nGoroutine Profile ：报告goroutines的使用情况，有哪些goroutine，它们的调用关系是怎样的。活跃Goroutine的信息的记录，以及调用关系。仅在获取时取样一次。\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003ePprof可视化\u003c/h3\u003e\n\u003cp\u003e在Mac上安装graphviz执行以下命令\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003ebrew install graphviz\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e以本地文件形式获取分析结果\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003e先把信息 dump 到本地文件，然后用 go tool 去分析（生产环境通用的方式）\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e第三方工具：debugcharts\u003c/h1\u003e\n\u003cp\u003e一个可以实时查看go程序内存、CPU、GC、协程等变化情况的可视化工具。启用方式跟pprof类似，都是先import引入，然后开启端口监听即可。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport (\n\t_ \"github.com/mkevac/debugcharts\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\t//... do something\n\n\tlog.Println(http.ListenAndServe(\"localhost:8090\", nil))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然后在浏览器中打开查看：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"http://127.0.0.1:8090/debug/charts/\"\u003ehttp://127.0.0.1:8090/debug/charts/\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e第三方工具：prometheus\u003c/h2\u003e\n\u003cp\u003eprometheus是grafana的插件，支持go监控的可视化。\n启用方式先引入包：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e_ \"github.com/prometheus/client_golang/prometheus/promhttp\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然后增加路由：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e//prometheus\nhttp.Handle(\"/metrics\", promhttp.Handler())\nhttp.ListenAndServe(\":8090\", nil)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最后，通过访问 \u003ca href=\"http://127.0.0.1:8090/metrics\"\u003ehttp://127.0.0.1:8090/metrics\u003c/a\u003e 查看采集到的指标数据。\u003c/p\u003e\n\u003cp\u003e** 可以通过一个端口同时开启pprof + charts + prometheus **\u003c/p\u003e\n\u003ch1\u003ego tool [xxx]\u003c/h1\u003e\n\u003cp\u003e输入 go tool 查看内置的所有[xxx]工具命令\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003eaddr2line\napi\nasm\nbuildid\ncgo\ncompile：代码汇编\ncover：生成代码覆盖率\ndist\ndoc\nfix\nlink\nnm：查看符号表（等同于系统 nm 命令）\nobjdump：反汇编工具，分析二进制文件（等同于系统 objdump 命令）\noldlink\npack\npprof：性能和指标分析工具\ntest2json\ntrace：采样一段时间，指标跟踪分析工具\nvet\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003ego tool nm 查看符号表的命令\u003c/h2\u003e\n\u003cp\u003e在断点的时候，如果不知道断点的函数符号，可以用这个命令进行查询（命令处理的是二进制程序文件）。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ego tool nm ./main\n输出的第一列是地址，第二列是类型，第三列是符号。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003e 115aa00 T bufio.(*ReadWriter).Available\n 115aa20 T bufio.(*ReadWriter).Discard\n 115aa60 T bufio.(*ReadWriter).Flush\n 115aa80 T bufio.(*ReadWriter).Peek\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003ego tool compile 汇编某个文件\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003ego tool compile -N -l -S main.go\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003ego tool objdump 反汇编二进制的工具\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003ego tool objdump main.o\ngo tool objdump -s DoFunc main.o  //反汇编具体函数\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ego tool pprof 性能指标分析工具\u003c/h2\u003e\n\u003ch3\u003e命令行分析模式\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003ego tool pprof \u003ca href=\"http://localhost:8090/debug/pprof/heap?second=10\"\u003ehttp://localhost:8090/debug/pprof/heap?second=10\u003c/a\u003e 分析heap，进入命令行模式，输入 web 即可以web方式打开（前提是安装了graphviz）。或者继续输入命令：\n在命令行输入top默认查看程序中占用内存前10位的函数\n在命令行输入top 3可以查看程序中占用内存前3位的函数\n同样，如果采集的是cpu使用top命令可以看占用cpu的函数\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e输入top后显示的最后一列为函数名称，其他各项内容意义如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003eflat：当前函数占用CPU的耗时\nflat%：当前函数占用CPU的耗时百分比\nsum%：函数占用CPU的累积耗时百分比\ncum：当前函数+调用的子函数 占用CPU总耗时\ncum%：当前函数+调用的子函数 占用CPU总耗时百分比\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e可以在命令行输入 list+函数名 命令查看具体的函数分析\n可以在命令行输入 pdf 生成可视化的pdf文件\n可以在命令行输入 help 提供所有pprof支持的命令说明\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003eweb分析模式\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003ego tool pprof -http=:1234 \u003ca href=\"http://localhost:8090/debug/pprof/heap?second=10\"\u003ehttp://localhost:8090/debug/pprof/heap?second=10\u003c/a\u003e 会直接以web方式打开。或者：\n\u003ca href=\"http://localhost:1234/ui/\"\u003ehttp://localhost:1234/ui/\u003c/a\u003e 也可以直接打开，从中可以直接筛选查看火焰图（Flame Graph）。\n-http 表示使用交互式web接口查看获取的性能信息，指定可用的端口即可。\ndebug/pprof/需要查看的指标（allocs,block,goroutine,heap等）\n火焰图从上往下是方法的调用栈，长度代表使用的cpu时长。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e其他的一些go tool pprof 分析命令\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003ego tool pprof -http=:1234 \u003ca href=\"http://localhost:8090/debug/pprof/goroutine?second=10\"\u003ehttp://localhost:8090/debug/pprof/goroutine?second=10\u003c/a\u003e\ngo tool pprof --seconds 10 \u003ca href=\"http://localhost:8090/debug/pprof/goroutine\"\u003ehttp://localhost:8090/debug/pprof/goroutine\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如果应用比较复杂，生成的调用图特别大，看起来很乱，有两个办法可以优化：\n使用 web [funcName] 的方式，只打印和某个函数相关的内容\n运行 go tool pprof 命令时加上 --nodefration 参数，可以忽略内存使用较少的函数，比如--nodefration=0.05表示如果调用的子函数使用的 CPU、memory 不超过 5%，就忽略它，不要显示在图片中\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ego test 单元测试\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e_test.go 结尾的文件认为是测试文件\n本质上，golang 跑单测是先编译 *_test.go 文件，编译成二进制后，再运行这个二进制文件\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003ego test .    //直接在本目录中运行go test\ngo test -run=TestPutAndGetKeyValue    //指定运行函数\ngo test -v    //提供详细的测试输出，打印测试名称、状态（通过或者失败）、耗时、测试用例的日志等\n\ngo test -race    //测试时支持对竞争进行检测和报告\ngo test -coverprofile=c.out \u0026#x26;\u0026#x26; go tool cover -html=c.out    //输出一个覆盖信息结果并可在浏览器上可视化观看\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e编译生成单元测试可执行文件\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003e// 先编译出 .test 文件\n$ go test -c \n// 指定跑某一个文件\n$ ./raftexample.test -test.timeout=10m0s -test.v=true -test.run=TestPutAndGetKeyValue\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e统计代码覆盖率\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e加一个 -coverprofile 的参数，声明在跑单测的时候，记录代码覆盖率\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003ego test -coverprofile=coverage.out\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e使用 go tool cover 命令分析，得出覆盖率报告\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003ego tool cover -func=coverage.out\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003eDelve\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003edelve 当前是最友好的 golang 调试程序，ide 调试其实也是调用 dlv 而已，比如 goland\n安装dlv：\ngo get -u github.com/go-delve/delve/cmd/dlv\n检查安装版本信息：\ndlv version\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e把程序加载进 Delve 调试器的两种方式（事先需要有go.mod）\u003c/h2\u003e\n\u003ch3\u003e加载源码进行调试\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003edlv debug\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e执行 dlv debug 进入命令行模式，此时同目录下会自动生成一个 __debug_bin 文件。这个文件是由源码编译生成的，并会自动加载进调试器。\u003c/li\u003e\n\u003cli\u003eDelve 期望的是从单个程序或项目中构建出单个二进制文件，如果目录中有多个源文件且每个文件都有自己的主函数， Delve 则可能抛出错误。此种情况下应该使用下面第二种方式，加载二进制文件进行调试。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e加载二进制文件进行调试\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003edlv exec ./main\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e使用 dlv exec 命令将二进制文件加载进调试器。\u003c/li\u003e\n\u003cli\u003e在命令行模式下输入 help 查看可用命令。\u003c/li\u003e\n\u003cli\u003e常使用的一些命令：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003eb main.main     //在 main 函数处设置断点，等同于 break main.main\nb func.go:5     //使用 文件名:行号 的格式来设置断点，也可以直接用行号设置断点\nbp                  //查看设置的断点，等同于 breakpoints\nclear [断点标号如2]          //清除单个断点\nclearall            //清除所有断点\non                  //设置一段命令，当断点命中的时候\nc                   //继续运行程序，运行到断点处中止，等同于 continue\nn                   //单步调试下一行源码，等同于 next。默认情况下，Delve不会更深入地调试函数调用。\ns                   //单步调试下一个函数，等同于 step\nstep-instruction    //单步调试某个汇编指令\nstack              //打印当前堆栈的内容信息，可以看到0、1、2、3...等栈位置的函数\nframe 0           //实现帧之间的跳转，可以使用 stack 输出的位置序号\nargs                //打印出命令行传给函数的参数\ndisassemble    //查看编译器生成的汇编语言指令\nstepout           //跳回到函数被调用的地方\nprint [var_name]         //打印变量的值\nwhatis [var_name]        //打印变量的类型\nlocals                //打印函数内的所有局部变量\nregs                    //打印寄存器的信息\nx                       //等同于examinemem，这个是解析内存用的，和 gdb 的 x 命令一样\nset                     //set赋值\nvars                    //打印全局变量（包变量）\nwhatis                  //打印类型信息\nr                       //重新启动并调试执行程序，等同于restart\ncall                    //整个程序执行\nquit                //退出调试器\n\n协程相关\ngoroutine (alias: gr)       //打印某个特定协程的信息\ngoroutines (alias: grs)     //列举所有的协程\ngoroutines -t                   //展开所有协程详细信息\nthread (alias: tr)              //切换到某个线程\nthreads                         //打印所有的线程信息\n\n栈相关\ndeferred                    //在 defer 函数上下文里执行命令\ndown                        //上堆栈\nframe                       //跳到某个具体的堆栈\nstack (alias: bt)          //打印堆栈信息\nup                           //下堆栈\n\n其他命令\nconfig                      //配置变更\ndisassemble (alias: disass)     //反汇编\nfuncs                           //打印所有函数符号\nlibraries                       //打印所有加载的动态库\nlist (alias: ls | l)            //显示源码\nsource                      //加载命令\nsources                     //打印源码\ntypes                       //打印所有类型信息\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003edlv的其它命令\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003edlv debug：使用dlv debug可以在main函数文件所在目录直接对main函数进行调试，也可以在根目录以指定包路径的方式对main函数进行调试\ndlv exec：使用dlv exec可以对编译好的二进制进行调试\ndlv test：使用dlv test可以对test包进行调试\ndlv attach：使用dlv attach可以附加到一个已在运行的进程进行调试\ndlv connect：使用dlv connect可以连接到调试服务器进行调试\ndlv trace：使用dlv trace可以追踪程序\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003ego race\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eGo 语言提供了 race 检测（Go race detector）来进行竞争分析和发现\u003c/li\u003e\n\u003cli\u003ego run -race main.go 是运行时检测，并不是编译时。且使用 race 时存在明显的性能开销，因此不要在生产环境中使用这个。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1\u003eGDB\u003c/h1\u003e\n\u003ch2\u003egdb当前只支持6个命令\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e3个 cmd 命令\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003einfo goroutines         //打印所有的goroutines\ngoroutine ${id} bt      //打印一个goroutine的堆栈\niface                       //打印静态或者动态的接口类型\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e3个函数\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-txt\"\u003elen                         //打印string，slices，map，channels 这四种类型的长度\ncap                         //打印slices，channels 这两种类型的cap\ndtype                       //强制转换接口到动态类型。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003egdb 有一个功能是无法替代的，就是 gcore 的功能\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003eGOGC 环境变量\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eGo垃圾回收提供了一个参数GOGC。\u003c/li\u003e\n\u003cli\u003eGOGC代表了占用中的内存增长比率，达到该比率时应当触发1次GC，该参数可以通过环境变量进行设置。。\u003c/li\u003e\n\u003cli\u003eGOGC参数取值范围为0~100，其默认值是100，单位是百分比。\n假如当前heap占用内存为4MB，GOGC = 75，则 4*(1+75%)=7MB，即heap占用内存大小达到7MB时会触发1轮GC。\u003c/li\u003e\n\u003cli\u003eGOGC还有2个特殊值：\n“off” : 代表关闭GC\n0 : 代表持续进行垃圾回收，只用于调试。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1\u003eruntime.MemStats\u003c/h1\u003e\n\u003cp\u003e通过runtime.MemStats可以实时的获取 Go 运行时的内存统计信息，这个数据结构包含很多的字段。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003etype MemStats struct {\n        // 已分配的对象的字节数.\n        //\n        // 和HeapAlloc相同.\n        Alloc uint64\n\n        // 分配的字节数累积之和.\n        //\n        // 所以对象释放的时候这个值不会减少.\n        TotalAlloc uint64\n\n        // 从操作系统获得的内存总数.\n        //\n        // Sys是下面的XXXSys字段的数值的和, 是为堆、栈、其它内部数据保留的虚拟内存空间.\n        // 注意虚拟内存空间和物理内存的区别.\n        Sys uint64\n\n        // 运行时地址查找的次数，主要用在运行时内部调试上.\n        Lookups uint64\n\n        // 堆对象分配的次数累积和.\n        // 活动对象的数量等于`Mallocs - Frees`.\n        Mallocs uint64\n\n        // 释放的对象数.\n        Frees uint64\n\n        // 分配的堆对象的字节数.\n        //\n        // 包括所有可访问的对象以及还未被垃圾回收的不可访问的对象.\n        // 所以这个值是变化的，分配对象时会增加，垃圾回收对象时会减少.\n        HeapAlloc uint64\n\n        // 从操作系统获得的堆内存大小.\n        //\n        // 虚拟内存空间为堆保留的大小，包括还没有被使用的.\n        // HeapSys 可被估算为堆已有的最大尺寸.\n        HeapSys uint64\n\n        // HeapIdle是idle(未被使用的) span中的字节数.\n        //\n        // Idle span是指没有任何对象的span,这些span **可以**返还给操作系统，或者它们可以被重用,\n        // 或者它们可以用做栈内存.\n        //\n        // HeapIdle 减去 HeapReleased 的值可以当作\"可以返回到操作系统但由运行时保留的内存量\".\n        // 以便在不向操作系统请求更多内存的情况下增加堆，也就是运行时的\"小金库\".\n        //\n        // 如果这个差值明显比堆的大小大很多，说明最近在活动堆的上有一次尖峰.\n        HeapIdle uint64\n\n        // 正在使用的span的字节大小.\n        //\n        // 正在使用的span是值它至少包含一个对象在其中.\n        // HeapInuse 减去 HeapAlloc的值是为特殊大小保留的内存，但是当前还没有被使用.\n        HeapInuse uint64\n\n        // HeapReleased 是返还给操作系统的物理内存的字节数.\n        //\n        // 它统计了从idle span中返还给操作系统，没有被重新获取的内存大小.\n        HeapReleased uint64\n\n\n        // HeapObjects 实时统计的分配的堆对象的数量,类似HeapAlloc.\n        HeapObjects uint64\n\n        // 栈span使用的字节数。\n        // 正在使用的栈span是指至少有一个栈在其中.\n        //\n        // 注意并没有idle的栈span,因为未使用的栈span会被返还给堆(HeapIdle).\n        StackInuse uint64\n\n        // 从操作系统取得的栈内存大小.\n        // 等于StackInuse 再加上为操作系统线程栈获得的内存.\n        StackSys uint64\n\n        // 分配的mspan数据结构的字节数.\n        MSpanInuse uint64\n\n        // 从操作系统为mspan获取的内存字节数.\n        MSpanSys uint64\n\n        // 分配的mcache数据结构的字节数.\n        MCacheInuse uint64\n\n        // 从操作系统为mcache获取的内存字节数.\n        MCacheSys uint64\n\n        // 在profiling bucket hash tables中的内存字节数.\n        BuckHashSys uint64\n\n        // 垃圾回收元数据使用的内存字节数.\n        GCSys uint64 // Go 1.2\n\n        // off-heap的杂项内存字节数.\n        OtherSys uint64 // Go 1.2\n\n        // 下一次垃圾回收的目标大小，保证 HeapAlloc ≤ NextGC.\n        // 基于当前可访问的数据和GOGC的值计算而得.\n        NextGC uint64\n\n        // 上一次垃圾回收的时间.\n        LastGC uint64\n\n        // 自程序开始 STW 暂停的累积纳秒数.\n        // STW的时候除了垃圾回收器之外所有的goroutine都会暂停.\n        PauseTotalNs uint64\n\n        // 一个循环buffer，用来记录最近的256个GC STW的暂停时间.\n        PauseNs [256]uint64\n\n        // 最近256个GC暂停截止的时间.\n        PauseEnd [256]uint64 // Go 1.4\n\n        // GC的总次数.\n        NumGC uint32\n\n        // 强制GC的次数.\n        NumForcedGC uint32 // Go 1.8\n\n        // 自程序启动后由GC占用的CPU可用时间，数值在 0 到 1 之间.\n        // 0代表GC没有消耗程序的CPU. GOMAXPROCS * 程序运行时间等于程序的CPU可用时间.\n        GCCPUFraction float64 // Go 1.5\n\n        // 是否允许GC.\n        EnableGC bool\n\n        // 未使用.\n        DebugGC bool\n\n        // 按照大小进行的内存分配的统计,具体可以看Go内存分配的文章介绍.\n        BySize [61]struct {\n                // Size is the maximum byte size of an object in this\n                // size class.\n                Size uint32\n\n                // Mallocs is the cumulative count of heap objects\n                // allocated in this size class. The cumulative bytes\n                // of allocation is Size*Mallocs. The number of live\n                // objects in this size class is Mallocs - Frees.\n                Mallocs uint64\n\n                // Frees is the cumulative count of heap objects freed\n                // in this size class.\n                Frees uint64\n        }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eruntime.SetGCPercent\u003c/h1\u003e\n\u003cp\u003e可以通过设置runtime.SetGCPercent参数来调整GOGC垃圾回收的目标百分比。\n当这次新分配的数据和上一次垃圾回收后存活数据之比达到这个数值之后就会触发一次垃圾回收。\nGOGC的默认值是 100。设置GOGC=off会禁止垃圾回收。\u003c/p\u003e\n","date":"2016-05-09","title":"Go程序性能分析工具"},"prevPost":{"summary":null,"tags":["Golang"],"id":"golang-strings","title":"Go字符串处理","date":"2016-05-27"},"nextPost":{"summary":null,"tags":["Golang"],"id":"golang-concurrent-programming-practices","title":"Go并发编程实践","date":"2016-05-02"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"golang-program-performance-analysis-tools"},"buildId":"34lywmESJ-J9QrCtAq08O","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
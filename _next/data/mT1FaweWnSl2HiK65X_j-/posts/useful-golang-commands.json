{"pageProps":{"post":{"summary":null,"tags":["Golang"],"id":"useful-golang-commands","contentHtml":"<p>一些实用的Go工具命令</p>\n<!-- more -->\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>gofmt -w -l -r \"panic(err) -> log.Error(err)\" .</td>\n<td>格式化并替换文本</td>\n</tr>\n<tr>\n<td>go test -v</td>\n<td>将 t.Log 的输出变成实时流式，而不是在整个测试结束之后输出</td>\n</tr>\n<tr>\n<td>go mod why -m <module></td>\n<td>分析特定的模块为什么会在 go.mod 文件中</td>\n</tr>\n</tbody>\n</table>\n<h1>Go语言自带工具集</h1>\n<pre><code class=\"language-txt\">bug         start a bug report\nbuild       compile packages and dependencies\nclean       remove object files and cached files\ndoc         show documentation for package or symbol\nenv         print Go environment information\nfix         update packages to use new APIs\nfmt         gofmt (reformat) package sources\ngenerate    generate Go files by processing source\nget         add dependencies to current module and install them\ninstall     compile and install packages and dependencies\nlist        list packages or modules\nmod         module maintenance\nrun         compile and run Go program\ntest        test packages\ntool        run specified go tool\nversion     print Go version\nvet         report likely mistakes in packages\n</code></pre>\n<h1>go generate</h1>\n<ol>\n<li>go generate常用于自动生成代码，它可以在代码编译之前根据源代码生成代码。</li>\n<li>当运行go generate时，它将扫描与当前包相关的源代码文件，找出所有包含\"// go:generate\"的注释语句，提取并执行该注释后的命令，命令为可执行程序。</li>\n<li>该过程类似于调用执行shell脚本。</li>\n</ol>\n<p>添加特殊注释</p>\n<blockquote>\n<p>//go:generate command argument...</p>\n</blockquote>\n<p>执行generate命令</p>\n<blockquote>\n<p>go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]</p>\n</blockquote>\n<h3>注意事项</h3>\n<ol>\n<li>该特殊注释必须包含在.go源码文件中。</li>\n<li>每个源码文件可以包含多个generate特殊注释。</li>\n<li>go generate不会被类似go build，go get，go test等命令触发执行，必须由开发者显式使用。</li>\n<li>命令执行是串行的，如果出错，后续命令不再执行。</li>\n<li>特殊注释必须以“//go:generate”开头，双斜线之后没有空格。</li>\n<li>执行命令必须是系统PATH（echo $PATH）下的可执行程序。</li>\n</ol>\n<h3>go generate 示例</h3>\n<pre><code class=\"language-go\">package main\n\nimport \"fmt\"\n\n//go:generate echo HelloWorld!\n//go:generate go run main.go\n//go:generate echo $GOARCH $GOOS $GOFILE $GOLINE $GOPACKAGE\n\nfunc main() {\n fmt.Println(\"go run main.go!\")\n}\n</code></pre>\n<h3>常用场景</h3>\n<p>为枚举常量实现String方法</p>\n<blockquote>\n<p>//go:generate stringer -type=XXXXX(枚举的别名)</p>\n</blockquote>\n<p>首先安装Go官方工具stringer：</p>\n<blockquote>\n<p>go install golang.org/x/tools/cmd/stringer</p>\n</blockquote>\n<h1>其它常用命令</h1>\n<blockquote>\n<p>go tool compile -S main.go  生成汇编代码\ngo build -gcflags -S main.go</p>\n</blockquote>\n<h3>禁止内联</h3>\n<pre><code class=\"language-go\">//go:noinline\nfunc smallAllocation() *smallStruct {\n   return &#x26;smallStruct{}\n}\n</code></pre>\n<h1>逃逸分析命令</h1>\n<blockquote>\n<p>go tool compile -S main.go    //输出汇编内容，从中也可以看出逃逸的信息。用 go tool compile -help 可以查看所有可以传递给编译器的标识参数\ngo build -gcflags '-N -l -m' main.go    //禁止优化、禁止内联、打印逃逸分析信息</p>\n</blockquote>\n<h1>GODEBUG</h1>\n<h2>GC垃圾回收分析命令</h2>\n<blockquote>\n<p>GODEBUG=gctrace=1 go run main.go</p>\n</blockquote>\n<h2>调度器观察参数</h2>\n<blockquote>\n<p>GODEBUG=schedtrace=100 go run main.go    //在运行时每100毫秒发出一行调度器的摘要信息到标准err输出中\nGODEBUG=scheddetail=1,schedtrace=100 go run main.go    //在运行时每100毫秒发出一次详细的多行信息，信息内容包括调度程序、处理器、OS线程和goroutine的状态</p>\n</blockquote>\n<p>说明如下：</p>\n<pre><code class=\"language-txt\">**GODEBUG=schedtrace=100 go run main.go**\nSCHED 0ms: gomaxprocs=16 idleprocs=14 threads=4 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n# command-line-arguments\nSCHED 0ms: gomaxprocs=16 idleprocs=14 threads=3 spinningthreads=1 idlethreads=0 runqueue=0 [2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\nSCHED 104ms: gomaxprocs=16 idleprocs=15 threads=20 spinningthreads=1 idlethreads=13 runqueue=0 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n# command-line-arguments\nSCHED 0ms: gomaxprocs=16 idleprocs=14 threads=3 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\nSCHED 207ms: gomaxprocs=16 idleprocs=16 threads=20 spinningthreads=0 idlethreads=13 runqueue=0 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\nSCHED 316ms: gomaxprocs=16 idleprocs=16 threads=20 spinningthreads=0 idlethreads=13 runqueue=0 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\nSCHED 0ms: gomaxprocs=16 idleprocs=13 threads=5 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\nSCHED 416ms: gomaxprocs=16 idleprocs=15 threads=20 spinningthreads=1 idlethreads=13 runqueue=0 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\nSCHED 100ms: gomaxprocs=16 idleprocs=16 threads=5 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\nSCHED 526ms: gomaxprocs=16 idleprocs=16 threads=20 spinningthreads=0 idlethreads=13 runqueue=0 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n\n解释：\nsched：每一行都代表调度器的调试信息，后面的毫秒数是表示从启动到现在的时间，是由schedtrace值设置的。\ngomaxprocs：当前的cpu核心数\nidleprocs：空闲的处理器数量\nthreads：OS线程数量，后面的数字表示当前正在运行的线程数量\nspinningthreads：自旋状态的OS线程数量。（调度器的设计者在考虑了“OS的资源利用率”和“频繁的线程抢占给OS带来的负载”之后，提出了自旋线程的概念。当自旋线程没有找到可供其调度执行的goroutine时，并不会销毁改线程，而是采取自旋的操作保存了下来。虽然看起来浪费了一些资源，但是考虑一下syscall的情景就可以知道，比起自旋操作，线程间频繁的抢占、创建和销毁操作带来的危害更大。）\nidlethreads：空闲的线程数量\nrunqueue：全局队列中的goroutine数量，后面的[0 ...]表示这16个P的本地队列正在运行的goroutine数量。\n</code></pre>\n<pre><code class=\"language-txt\">**GODEBUG=scheddetail=1,schedtrace=100 go run main.go**\nSCHED 0ms: gomaxprocs=16 idleprocs=14 threads=4 spinningthreads=1 idlethreads=0 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0\n  P0: status=1 schedtick=0 syscalltick=0 m=0 runqsize=0 gfreecnt=0 timerslen=0\n  P1: status=1 schedtick=0 syscalltick=0 m=3 runqsize=0 gfreecnt=0 timerslen=0\n  P2: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0\n  P3: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0\n  P4: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0\n  P5: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0\n  P6: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0\n  P7: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0\n  P8: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0\n  P9: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0\n  P10: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0\n  P11: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0\n  P12: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0\n  P13: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0\n  P14: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0\n  P15: status=0 schedtick=0 syscalltick=0 m=-1 runqsize=0 gfreecnt=0 timerslen=0\n  M3: p=1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=2 dying=0 spinning=false blocked=false lockedg=-1\n  M2: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=2 dying=0 spinning=false blocked=false lockedg=-1\n  M1: p=-1 curg=17 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=false lockedg=17\n  M0: p=0 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=1\n  G1: status=1() m=-1 lockedm=0\n  G17: status=6() m=1 lockedm=1\n  G2: status=1() m=-1 lockedm=-1\n\n解释：\nG的运行状态共有 9 种，分别为：\n（1）\n（2）\n（3）\n（4）\n（5）\n（6）\n（7）\n（8）\n（9）\n\n</code></pre>\n","date":"2018-02-02T10:00:00.000Z","title":"一些实用的Go工具命令","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["Docker"],"id":"docker-commands-middleware-example","title":"Docker常用命令及中间件应用示例","date":"2018-02-03T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false},"nextPost":{"summary":null,"tags":["英语"],"id":"holidays-in-english","title":"节假日的英文表述","date":"2018-02-02T10:00:00.000Z","published":true,"hideInList":false,"feature":null}},"__N_SSG":true}
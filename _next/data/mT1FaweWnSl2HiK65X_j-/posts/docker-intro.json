{"pageProps":{"post":{"summary":null,"tags":["Docker"],"id":"docker-intro","contentHtml":"<p>此篇记录使用Docker的一些基本概念和操作。</p>\n<!-- more -->\n<h1>虚拟机和容器</h1>\n<blockquote>\n<p>虚拟机 -> 模拟整个计算机，容器 -> 只提供操作系统级别的虚拟化。\nDocker本质上就是一种管理容器的平台软件。Docker是对运行特定应用所需的全部程序（包括操作系统在内）的一种轻量级虚拟化。\nDocker引擎由Docker客户端、Docker守护进程以及不同的Docker容器组成，这些容器为Docker镜像的实例。\nDocker镜像可以通过Dockerfile创建，并且镜像还能够存储在Docker注册中心（registy）中。</p>\n</blockquote>\n<h1>Docker 架构</h1>\n<ol>\n<li>Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。</li>\n<li>客户端和服务器可以运行在一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。</li>\n</ol>\n<h1>Docker 的核心组件</h1>\n<ol>\n<li>Docker 客户端：client</li>\n<li>Docker 服务器：Docker daemon</li>\n<li>Docker 镜像：Image</li>\n<li>Registry</li>\n<li>Docker 容器：Container</li>\n</ol>\n<h1>Docker的三个基本概念</h1>\n<h2>镜像（Image）</h2>\n<ul>\n<li>由一组文件系统（多层文件系统）联合组成。</li>\n<li>镜像是静态的定义，类似于一个只读模板。</li>\n<li>有好几种不同的方法可以创建Docker镜像，其中一种就是在一个名为Dockerfile的文件里包含一系列指令。</li>\n<li>容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。</li>\n<li>只有当需要修改时才复制一份数据，这种特性被称作 <strong>Copy-on-Write</strong>。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。</li>\n</ul>\n<h2>容器（Container）</h2>\n<ul>\n<li>容器是镜像运行时的实体。</li>\n<li>容器是一种轻量级、可移植、自包含的软件打包技术，使应用程序可以在几乎任何地方以相同的方式运行。容器使软件具备了超强的可移植能力。</li>\n<li>容器可以被创建、启动、停止、删除、暂停等。</li>\n<li>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。</li>\n<li>容器在运行时会为读写准备一个临时存储层，称为<strong>容器存储层</strong>。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</li>\n<li>容器不应该向其存储层内写入任何数据，容器存储层要保持<strong>无状态化</strong>。所有的文件写入操作，都应该使用 <strong>数据卷（Volume）</strong>、或者<strong>绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</li>\n</ul>\n<h2>仓库（Repository）</h2>\n<ul>\n<li>一个集中的存储、分发镜像的服务。</li>\n<li>可以通过 <strong>&#x3C;仓库名>:&#x3C;标签></strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</li>\n<li>最常使用的 Registry 公开服务是官方的 Docker Hub（ <a href=\"https://hub.docker.com\">https://hub.docker.com</a> ）， 这也是默认的 Registry，并拥有大量的高质量的官方镜像。Docker Hub提供公开和私有的Docker镜像，但私有的Docker镜像需要付费才能使用。</li>\n</ul>\n<h1>Docker架构</h1>\n<ol>\n<li>Docker client客户端：Docker的客户端向Docker Daemon发起请求。</li>\n<li>Docker Daemon守护进程：Docker是C/S架构的程序，Docker的客户端向守护进程发起请求，守护进程处理完成后返回结果。Docker客户端既可以在本地访问守护进程，也可以通过 socket 或 REST API 远程访问守护进程。</li>\n<li>Docker Image镜像：Docker 容器运行时的只读模板。</li>\n<li>Docker Container容器：Docker 容器和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境。</li>\n<li>Docker Registry仓库：Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库</li>\n<li>Docker Network网络：Docker网络用来保证容器之间，以及容器的内外部通信。\n<img src=\"https://ninglg.com/post-images/1583165412449.jpg\" alt=\"\"></li>\n</ol>\n<h1>安装 Docker</h1>\n<p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费），EE 即企业版，强调安全，付费使用。</p>\n<h1>Docker 命令</h1>\n<ol>\n<li>验证安装正确</li>\n</ol>\n<blockquote>\n<p>docker version\ndocker info</p>\n</blockquote>\n<ol>\n<li>运行一个 Nginx 服务器</li>\n</ol>\n<blockquote>\n<p>docker run -d -p 80:80 --name webserver nginx</p>\n</blockquote>\n<ul>\n<li>服务运行后访问 <a href=\"http://localhost\">http://localhost</a> ，如果看到了 \"Welcome to nginx!\" 说明 Docker 安装成功。</li>\n<li>要停止 Nginx 服务器并删除执行下面的命令：</li>\n</ul>\n<blockquote>\n<p>docker stop webserver\ndocker rm webserver</p>\n</blockquote>\n<ol start=\"3\">\n<li>从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：</li>\n</ol>\n<blockquote>\n<p>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</p>\n</blockquote>\n<ul>\n<li>具体的选项可以通过 docker pull --help 命令看到。</li>\n<li>Docker 镜像仓库地址的格式一般是 &#x3C;域名/IP>[:端口号]。默认地址是 Docker Hub。</li>\n<li>仓库名是两段式名称，即 &#x3C;用户名>/&#x3C;软件名>。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</li>\n<li>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。</li>\n</ul>\n<ol start=\"4\">\n<li>运行容器的命令</li>\n</ol>\n<blockquote>\n<p>docker run\n例如：\ndocker run hello-world\ndocker run -it ubuntu bash\ndocker run -i -t centos</p>\n</blockquote>\n<ol start=\"5\">\n<li>列出镜像</li>\n</ol>\n<blockquote>\n<p>docker image ls\ndocker image ls -a\ndocker image ls xxxxx</p>\n</blockquote>\n<ol start=\"6\">\n<li>查看镜像、容器、数据卷所占用的空间</li>\n</ol>\n<blockquote>\n<p>docker system df</p>\n</blockquote>\n<ol start=\"7\">\n<li>删除无用的虚悬镜像</li>\n</ol>\n<blockquote>\n<p>docker image prune</p>\n</blockquote>\n<ol start=\"8\">\n<li>删除本地镜像</li>\n</ol>\n<blockquote>\n<p>docker image rm [选项] &#x3C;镜像1> [&#x3C;镜像2> ...]\ndocker rmi IMAGE_NAME|IMAGE_ID</p>\n</blockquote>\n<ol start=\"9\">\n<li>其它</li>\n</ol>\n<blockquote>\n<p>-d 让容器在后台运行\n-p 指定端口映射，格式为主机(宿主)端口:容器端口\n--restart 重启模式，设置 always，每次启动 Docker 都会启动 Nginx 容器。</p>\n</blockquote>\n<p>例如：</p>\n<blockquote>\n<p>docker run -d -p 80:80 nginx    // 启动nginx容器，并映射到宿主机的80端口\n访问 <a href=\"http://localhost\">http://localhost</a> 进行验证\ndocker ps -n 5    // 查看容器list及状态\ndocker stop [CONTAINER ID]    // 停止nginx容器</p>\n</blockquote>\n<h1>Dockerfile</h1>\n<p>Dockerfile的基本指令有十三个。下面介绍常用的几个：</p>\n<h2>FROM</h2>\n<p>所有Dockerfile的第一个指令都必须是 FROM，用于指定一个构建镜像的基础源镜像，如果本地没有就会从公共库中拉取，没有指定镜像的标签会使用默认的latest标签，如果需要在一个Dockerfile中构建多个镜像，可以使用多次。</p>\n<h2>MAINTAINER</h2>\n<p>描述镜像的创建者，名称和邮箱。</p>\n<h2>RUN</h2>\n<p>RUN命令是一个常用的命令，启动某个镜像。执行完成之后会成为一个新的镜像，通常用于运行安装任务从而向映像中添加额外的内容。</p>\n<h2>COPY</h2>\n<p>复制本机文件或目录，添加到指定的容器目录中。</p>\n<h2>WORKDIR</h2>\n<p>为RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续参数如果是相对路径，则会基于之前命令指定的路径。</p>\n<h2>ENTRYPOINT</h2>\n<p>在启动容器的时候提供一个默认的命令项。</p>\n<h1>docker安装redis</h1>\n<h2>搜索镜像</h2>\n<blockquote>\n<p>docker search redis</p>\n</blockquote>\n<h2>加载redis镜像</h2>\n<blockquote>\n<p>docker pull redis</p>\n</blockquote>\n<h2>启动redis容器</h2>\n<blockquote>\n<p>docker run -p 6379:6379 -v $PWD/data:/data  -d redis redis-server --appendonly yes --requirepass \"123456\"</p>\n</blockquote>\n<h2>查看运行的容器</h2>\n<blockquote>\n<p>docker ps</p>\n</blockquote>\n<h2>设置自启</h2>\n<blockquote>\n<p>docker update --restart=always [容器id]</p>\n</blockquote>\n<h2>进入redis镜像</h2>\n<blockquote>\n<p>docker exec -it 容器ID redis-cli</p>\n</blockquote>\n<h1>创建Docker映像</h1>\n<blockquote>\n<p>docker build -t docker-xxx:0.1 .</p>\n</blockquote>\n<p>或者</p>\n<blockquote>\n<p>docker build <docker-file></p>\n</blockquote>\n<h1>Docker远程访问</h1>\n<p>docker的远程访问一般占用2375端口。</p>\n<h1>Docker其它管理</h1>\n<ol>\n<li>Docker ps/top/stats 是原生的命令行监控工具。除了命令行，Docker 也提供了 stats API，用户可以通过 HTTP 请求获取容器的状态信息。</li>\n<li>Docker logs 是原生的日志工具。另外还有 logspout 对日志提供了路由功能，它可以收集不同容器的日志并转发给其它工具进行后处理。</li>\n</ol>\n<h1>Docker可视化管理工具</h1>\n<h2>1. UI For Docker</h2>\n<blockquote>\n<p>docker pull uifd/ui-for-docker\ndocker run -it -d --name docker-web -p 9500:9000 -v /var/run/docker.sock:/var/run/docker.sock docker.io/uifd/ui-for-docker\n然后通过浏览器访问 <a href=\"http://127.0.0.1:9500\">http://127.0.0.1:9500</a> 即可。</p>\n</blockquote>\n<h2>2. Portainer</h2>\n<blockquote>\n<p>docker volume create portainer_data\ndocker run -d -p 9500:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n然后通过浏览器访问 <a href=\"http://127.0.0.1:9500\">http://127.0.0.1:9500</a> 即可。</p>\n</blockquote>\n<h1>Docker实现原理</h1>\n<p>Docker的实现依赖Linux底层三大基础能力：\n1、chroot &#x26; pivot_root 模拟：模拟文件系统\n2、namespace 隔离：隔离进程\n3、CGroup 限制：限制资源访问量</p>\n","date":"2017-07-22T19:01:18.000Z","title":"Docker原理介绍","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["分布式系统"],"id":"distributed-transaction","title":"分布式事务","date":"2017-07-25T20:49:31.000Z","published":true,"hideInList":false,"feature":null,"isTop":false},"nextPost":{"summary":null,"tags":["微服务"],"id":"building-microservices","title":"微服务设计","date":"2017-07-20T11:34:30.000Z","published":true,"hideInList":false,"feature":null,"isTop":false}},"__N_SSG":true}
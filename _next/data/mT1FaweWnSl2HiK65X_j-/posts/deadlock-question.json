{"pageProps":{"post":{"summary":null,"tags":["操作系统"],"id":"deadlock-question","contentHtml":"<p>此篇介绍一下有关死锁的内容。</p>\n<!-- more -->\n<h2>什么是死锁</h2>\n<p>死锁是指多个进程因竞争资源而造成的一种僵持状态。若无外力作用，这些进程都将永远处于阻塞状态，不能再运行下去。</p>\n<h2>产生死锁的必要条件</h2>\n<ol>\n<li>互斥（Mutual exclusion）条件\n一个资源每次只能被一个进程使用；</li>\n<li>请求与保持（Hold and wait）条件\n一个进程因请求资源而阻塞时，对已获得的资源保持不放；</li>\n<li>不可剥夺（No preemption）条件\n进程已获得的资源，在没使用完之前，不能强行剥夺；</li>\n<li>环路等待（Circular wait）条件\n多个进程之间形成一种互相循环等待资源的关系。</li>\n</ol>\n<h2>死锁的预防（Deadlock Prevention）</h2>\n<ol>\n<li>首先，互斥条件无法被破坏；</li>\n<li>采用静态资源分配策略，破坏“部分分配”条件；</li>\n<li>允许进程剥夺使用其他进程占有的资源，从而破坏“不可剥夺”条件；</li>\n<li>采用资源有序分配法，破坏“环路”条件。</li>\n</ol>\n<h2>死锁的避免（Deadlock Avoidance）</h2>\n<p>避免死锁的著名算法：<strong>银行家算法</strong></p>\n<blockquote>\n<p>该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的需求，就满足申请者的需求。这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。</p>\n</blockquote>\n","date":"2017-12-16T15:58:21.000Z","title":"死锁的问题","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["操作系统"],"id":"select-poll-epoll-model","title":"聊聊select、poll、epoll模型","date":"2017-12-20T09:04:07.000Z","published":true,"hideInList":false,"feature":null,"isTop":false},"nextPost":{"summary":null,"tags":["Redis"],"id":"how-redis-implement-high-performance","title":"Redis如何实现的高性能","date":"2017-12-06T22:23:04.000Z","published":true,"hideInList":false,"feature":null,"isTop":false}},"__N_SSG":true}
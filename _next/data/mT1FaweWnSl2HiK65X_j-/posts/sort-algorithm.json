{"pageProps":{"post":{"summary":null,"tags":["算法"],"id":"sort-algorithm","contentHtml":"<p>排序算法</p>\n<!-- more -->\n<p>![](<a href=\"https://ninglg.com/post-images/1635821876784.jpg\">https://ninglg.com/post-images/1635821876784.jpg</a> =900x500)</p>\n<h1>冒泡排序</h1>\n<pre><code class=\"language-go\">func BubbleSort(data []int) {\n    n := len(data)\n\tif data == nil || n &#x3C; 2 {\n\t\treturn\n\t}\n\n\tfor i := 0; i &#x3C; n-1; i++ {\n\t\tfor j := 0; j &#x3C; n-i-1; j++ {\n            // 冒泡排序是一种交换排序，核心是冒泡，排序过程中两两比较相邻记录的元素，每轮确定一个元素的位置。\n\t\t\tif data[j] > data[j+1] {\n\t\t\t\tdata[j], data[j+1] = data[j+1], data[j]\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre>\n<h1>快速排序</h1>\n<pre><code class=\"language-go\">package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnums := []int{4, 7, 3, 1, 0, 9, 2, 8, 6, 5}\n\tQuickSort(nums, 0, 9)\n\tfmt.Println(nums)\n}\n\nfunc QuickSort(data []int, left, right int) {\n\tval := data[(left+right)/2]\n\n\ti, j := left, right\n\tfor data[j] > val {\n\t\tj--\n\t}\n\n\tfor data[i] &#x3C; val {\n\t\ti++\n\t}\n\n\tdata[i], data[j] = data[j], data[i]\n\ti++\n\tj--\n\n\t// 递归的方式\n\tif i &#x3C; right {\n\t\tQuickSort(data, i, right)\n\t}\n\n\tif j > left {\n\t\tQuickSort(data, left, j)\n\t}\n}\n</code></pre>\n<h1>插入排序</h1>\n<pre><code class=\"language-go\">func InsertSort(data []int) {\n\tn := len(data)\n\n\tfor i := 0; i &#x3C; n; i++ {\n\t\tt := data[i]\n\t\t// 类似于洗扑克牌，把每个元素插入到前面合适的位置上\n\t\tfor j := i - 1; j >= 0; j-- {\n\t\t\tif t &#x3C; data[j] {\n\t\t\t\t// 比较并插入\n\t\t\t\tdata[j+1], data[j] = data[j], t\n\t\t\t} else {\n\t\t\t\t//前面已经是排好序的，如果比最后一个还大，则此元素无需继续比较\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre>\n<h1>希尔排序</h1>\n<blockquote>\n<p>希尔排序的实质就是分组插入排序。\n先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</p>\n</blockquote>\n<pre><code class=\"language-go\">func ShellSort(data []int) {\n\tn := len(data)\n\th := 1\n\n\tfor h &#x3C; n/3 { //寻找合适的间隔h\n\t\th = 3*h + 1\n\t}\n\n\tfor h >= 1 {\n\t\t//将数组变为间隔h个元素有序\n\t\tfor i := h; i &#x3C; n; i++ {\n\t\t\t//间隔h插入排序\n\t\t\tfor j := i; j >= h &#x26;&#x26; data[j] &#x3C; data[j-h]; j -= h {\n\t\t\t\tdata[j], data[j-h] = data[j-h], data[j]\n\t\t\t}\n\t\t}\n\t\th /= 3\n\t}\n}\n</code></pre>\n<h1>选择排序</h1>\n<pre><code class=\"language-go\">func SelectionSort(data []int) {\n    n := len(data)\n    for i := 0; i &#x3C; n; i++ {\n        // 循环找到最小元素的坐标，每轮交换一个\n        m := i\n        for j := i + 1; j &#x3C; n; j++ {\n            if data[j] &#x3C; data[m] {\n                m = j\n            }\n        }\n        data[i], data[m] = data[m], data[i]\n    }\n}\n</code></pre>\n<h1>堆排序</h1>\n<h1>归并排序</h1>\n<h1>计数排序</h1>\n<h1>基数排序</h1>\n<h1>桶排序</h1>\n","date":"2010-10-20T10:00:00.000Z","title":"排序算法","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["阅读"],"id":"live-soft-skills-other-than-code-reading","title":"《软技能-代码之外的生存指南》阅读笔记","date":"2010-10-25T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false},"nextPost":{"summary":null,"tags":["算法"],"id":"search-algorithm","title":"查找算法","date":"2010-10-20T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false}},"__N_SSG":true}
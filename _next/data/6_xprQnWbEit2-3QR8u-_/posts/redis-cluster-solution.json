{"pageProps":{"post":{"summary":null,"tags":["Redis"],"id":"redis-cluster-solution","contentHtml":"<p>此篇简要介绍一下Redis的集群代理方案：Twemproxy。</p>\n<h1>背景</h1>\n<p>Redis单实例内存容量有限，为了提高系统承载能力，就必须使用到Redis集群</p>\n<p>根据执行分片的位置，可以分为三种分片方式：</p>\n<h1>集群技术</h1>\n<h2>1. 客户端分片</h2>\n<ol>\n<li>客户端分片：客户端使用一致性哈希等算法决定应当分布到哪个节点。</li>\n<li>由业务方的程序代码设置路由规则，直接对多个Redis实例进行分布式访问</li>\n<li>优点是可以灵活调整路由规则，另外性能比代理方式好一些（少了一个中间分发的环节）</li>\n<li>缺点是Redis实例数量变化时需要手动调整分片，升级麻烦，可运维性较差</li>\n</ol>\n<h2>2. 代理分片</h2>\n<ol>\n<li>代理分片：将客户端的请求发送到代理上，由代理转发到正确的节点上。</li>\n<li>通过增加一个对业务方使用透明的代理层，来执行分片工作</li>\n<li>增加代理层虽然带来了一些多余的性能损耗，但是可以容忍</li>\n<li>基于该机制的开源产品Twemproxy</li>\n</ol>\n<h2>3. 服务器分片：Redis Cluster</h2>\n<ol>\n<li>没有中心节点（和代理模式的重要不同之处）</li>\n<li>Redis Cluster将所有Key映射到多个Slot中，集群中每个Redis实例负责一部分，业务程序通过集成的Redis Cluster客户端进行操作。客户端可以向任一实例发出请求，如果所需数据不在该实例中，则该实例引导客户端自动去对应实例读写数据。</li>\n<li>缺点是这是一个非常重的方案，Redis Cluster的成员管理（节点名称、IP、端口、状态、角色）等，都通过节点之间两两通讯，定期交换并更新，缺少了Redis单例的“简单、可依赖”的特点</li>\n</ol>\n<h1>1. Twemproxy</h1>\n<p>Twemproxy是Twitter公司开发的，代理分片构建Redis集群的一个开源解决方案</p>\n<h2>优势</h2>\n<ol>\n<li>单线程工作，用C语言开发</li>\n<li>直接支持大部分Redis指令，对于业务层可以透明使用</li>\n<li>应用层不必关心连接失败,，由代理负责重连</li>\n<li>代理后边的升级，前端不关心，解决了HA的问题</li>\n<li>把Hash算法放到了代理上做，路由策略多样，支持<strong>HashTag</strong>, 通过HashTag可以自己设定将同一类型的key映射到同一个实例上去</li>\n<li>减少与redis的直接连接数，保持与redis的<strong>长连接</strong>，可设置代理与后台每个redis连接的数目</li>\n<li>自带<strong>一致性hash算法</strong>，能够将数据自动分片到后端多个redis实例上</li>\n<li>支持redis pipelining request，将多个连接请求，组成reids pipelining统一向redis请求\n高效，对连接的管理采用<strong>epoll机制</strong>，内部数据传输采用“<strong>Zero Copy</strong>”技术，以提高运行效率</li>\n</ol>\n<h3>高可用方案</h3>\n<p>因为Twemproxy本身是单点，所以需要用Keepalived做高可用方案</p>\n<p>Keepalived是一种实现高可用的方案，它的功能主要包括两方面：</p>\n<ol>\n<li>通过IP漂移，实现服务的高可用：服务器集群共享一个虚拟IP，同一时间只有一个服务器占有虚拟IP并对外提供服务，若该服务器不可用，则<strong>虚拟IP漂移</strong>（VIP自动切换的过程就称为IP漂移）至另一台服务器并对外提供服务</li>\n<li>对LVS应用服务层的应用服务器集群进行状态监控：若应用服务器不可用，则keepalived将其从集群中摘除，若应用服务器恢复，则keepalived将其重新加入集群中</li>\n</ol>\n<h3>性能</h3>\n<p>经过一层代理后，官方给出的极限情况性能下降20%</p>\n<h1>2. Codis</h1>\n<p>Codis是由豌豆荚于2014年11月开源的一种Redis集群解决方案。</p>\n<h2>组成</h2>\n<p>Codis是一个代理中间件，使用Go语言开发。其分为四个部分：</p>\n<pre><code>1. Codis Proxy (codis-proxy)\n2. Codis Dashboard (codis-config)\n3. Codis Redis (codis-server)\n4. ZooKeeper/Etcd\n</code></pre>\n<h2>优劣</h2>\n<p>Codis和Twemproxy最大的区别有两个：</p>\n<ol>\n<li>Codis支持动态水平扩展，对Client完全透明不影响服务的情况下可以完成增减redis实例的操作</li>\n<li>Codis是用Go语言写的并支持多线程而Twemproxy用C并只用单线程</li>\n</ol>\n<blockquote>\n<p>第2条又意味着：Codis在多核机器上的性能会好于Twemproxy，Codis的最坏响应时间可能会因为GC的STW而变大，不过Go1.5发布后会显著降低STW的时间；如果只用一个CPU的话Go语言的性能不如C，因此在一些短连接而非长连接的场景中，整个系统的瓶颈可能变成Accept新Tcp连接的速度，这时Codis的性能可能会差于Twemproxy。</p>\n</blockquote>\n<ol start=\"3\">\n<li>虽然Redis是单线程的，但Codis Proxy是多线程的(严格来说是goroutine), 启动的线程数是CPU的核数，是可以充分利用起多核的性能的</li>\n</ol>\n<h2>使用注意事项</h2>\n<p>官方的建议是单个集合的总容量不要超过1M，否则在迁移的时候会有卡顿感</p>\n<h1>3. Redis Cluster</h1>\n<blockquote>\n<p>客户端分片、Redis Cluster属于无中心化的集群方案，Codis、Tweproxy属于中心化的集群方案。</p>\n</blockquote>\n<ol>\n<li>采用中间加一层Proxy的中心化模式时，对Proxy的要求很高。因为Proxy一旦出现故障，那么操作这个Proxy的所有客户端都无法处理。要想实现Proxy的高可用，还需要另外的机制来实现，例如Keepalive。</li>\n<li>另外，增加一层Proxy进行转发，必然会有一定的性能损耗。</li>\n<li>除了客户端分片和上面提到的中心化的方案之外，还有比较好的解决方案么？Redis官方推出的Redis Cluster另辟蹊径，它没有采用中心化模式的Proxy方案，而是把请求转发逻辑一部分放在客户端，一部分放在了服务端，它们之间互相配合完成请求的处理。</li>\n<li>Redis把请求转发的逻辑放在了Smart Client中，要想使用Redis Cluster，必须升级Client SDK，这个SDK中内置了请求转发的逻辑，所以业务开发人员同样不需要自己编写转发规则，Redis Cluster采用16384个槽位进行路由规则的转发。</li>\n<li>Redis Cluster也提供了在线数据迁移、节点扩容缩容等功能，内部还内置了哨兵完成故障自动恢复功能，可见它是一个集成所有功能于一体的Cluster。因此它在部署时非常简单，不需要部署过多的组件，对于运维极其友好。</li>\n<li>Redis Cluster在节点数据迁移、扩容缩容时，对于客户端的请求处理也做了相应的处理。当客户端访问的数据正好在迁移过程中时，服务端与客户端制定了一些协议，来告知客户端去正确的节点上访问，帮助客户端订正自己的路由规则。</li>\n<li>虽然Redis Cluster提供了在线数据迁移的功能，但它的迁移性能并不高，迁移过程中遇到大key时还有可能长时间阻塞迁移的两个节点，这个功能相较于Codis来说，Codis数据迁移性能更好。</li>\n</ol>\n<p><img src=\"https://ninglg.com/post-images/1647781302790.png\" alt=\"\"></p>\n","date":"2018-01-18T10:00:00.000Z","title":"Redis集群方案介绍","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["算法"],"id":"rate-limit-algorithm-intro","title":"常见限流算法介绍","date":"2018-01-23T22:24:19.000Z","published":true,"hideInList":false,"feature":null,"isTop":false},"nextPost":{"summary":null,"tags":["Redis"],"id":"redis-memory-usage-analysis","title":"Redis的内存使用量分析","date":"2018-01-17T10:06:19.000Z","published":true,"hideInList":false,"feature":null,"isTop":false}},"__N_SSG":true}
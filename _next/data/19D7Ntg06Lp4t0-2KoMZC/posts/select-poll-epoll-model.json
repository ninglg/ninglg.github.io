{"pageProps":{"post":{"summary":null,"tags":["操作系统"],"id":"select-poll-epoll-model","contentHtml":"<p>此篇简要介绍一下epoll模型的内容。</p>\n<h2>select / poll / epoll</h2>\n<p>select、poll 和 epoll 三个都是 IO 多路复用的机制，可以监视多个描述符（fd）的读 / 写等事件。一旦某个描述符就绪（一般是读或者写事件发生了），就能够将发生的事件通知给关心的应用程序去处理该事件。</p>\n<h3>select 的缺点</h3>\n<ol>\n<li>每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；</li>\n<li>同时每次调用 select 都需要在内核遍历传递进来的所有 fd，这个开销在 fd 很多时也很大；</li>\n<li>select 支持的文件描述符数量只有 1024，非常小。</li>\n</ol>\n<h3>poll</h3>\n<p>poll 和 select 原理一样，不过相比较 select 而言，poll 可以支持大于 1024 个文件描述符。</p>\n<h3>epoll</h3>\n<p>相比较 select 和 poll，epoll 的最大特点是：</p>\n<ol>\n<li>epoll 现在是线程安全的，而 select 和 poll 不是。</li>\n<li>epoll 内部使用了 mmap 共享了用户和内核的部分空间，避免了数据的来回拷贝。</li>\n<li>epoll 基于事件驱动，epoll_ctl 注册事件并注册 callback 回调函数，epoll_wait 只返回发生的事件，避免了像 select 和 poll 对事件的整个轮询操作。</li>\n</ol>\n","date":"2017-12-20T09:04:07.000Z","title":"聊聊select、poll、epoll模型","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["操作系统"],"id":"page-replacement-algorithms-in-operating-systems","title":"操作系统常见的页面置换算法","date":"2017-12-25T02:01:50.000Z","published":true,"hideInList":false,"feature":null,"isTop":false},"nextPost":{"summary":null,"tags":["操作系统"],"id":"deadlock-question","title":"死锁的问题","date":"2017-12-16T15:58:21.000Z","published":true,"hideInList":false,"feature":null,"isTop":false}},"__N_SSG":true}
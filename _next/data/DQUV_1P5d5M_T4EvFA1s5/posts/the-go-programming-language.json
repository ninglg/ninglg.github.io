{"pageProps":{"post":{"summary":null,"tags":["Golang"],"id":"the-go-programming-language","contentHtml":"<p>《Go程序设计语言》阅读要点记录</p>\n<h1>第1章 入门</h1>\n<ol>\n<li>找出重复行</li>\n</ol>\n<pre><code class=\"language-go\">func main() {\n\tcounts := make(map[string]int)\n\tinput := bufio.NewScanner(os.Stdin)\n\tfor input.Scan() {\n\t\tcounts[input.Text()]++\n\t}\n\n// 忽略了input.Err()中可能的错误\n\tfor line, n := range counts {\n\t\tif n > 1 {\n\t\t\tprintln(line, n)\n\t\t}\n\t}\n}\n</code></pre>\n<p>（1）bufio.NewScanner可以读取输入，以行或者单词为单位隔开，这是处理以行为单位的输入内容的最简单方式；\n（2）每一次调用input.Scan()读取下一行，并且将结尾的换行符去掉；\n（3）通过调用input.Text()来获取读到的内容；\n（4）input.Scan()在读到新行的时候返回true，在没有更多内容的时候返回false；</p>\n<ol start=\"2\">\n<li>printf的部分格式</li>\n</ol>\n<pre><code class=\"language-txt\">%x, %o, %b      十六进制、八进制、二进制整数\n%v                  内置格式的任何值\n%T                  任何值的类型\n</code></pre>\n<ol start=\"3\">\n<li>读取文件</li>\n</ol>\n<pre><code class=\"language-go\">data, err := ioutil.ReadFile(filename)\n... ...\nfor _, line := range strings.Split(string(data), \"\\n\") {\n    counts[line]++\n}\n</code></pre>\n<ol start=\"4\">\n<li>产生随机数</li>\n</ol>\n<pre><code class=\"language-go\">rand.Seed(time.Now().UTC().UnixNano())\n... ...\nfreq := rand.Float64()\n</code></pre>\n<ol start=\"5\">\n<li>系统异常退出  os.Exit(1)</li>\n<li>获取url的内容</li>\n</ol>\n<pre><code class=\"language-go\">resp, err := http.Get(url)\n... ...\nb, err := ioutil.ReadAll(resp.Body)\nresp.Body.Close()\n</code></pre>\n<ol start=\"7\">\n<li>计算消耗的时间  time.Since(start).Seconds()</li>\n<li>一个Web服务器</li>\n</ol>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello, %s\", r.URL.Path)\n}\n</code></pre>\n<blockquote>\n<p>r中包含很多信息，比如r.Method，r.URL，r.Proto，r.Host，r.Form等。</p>\n</blockquote>\n<h1>第2章  程序结构</h1>\n<h1>第8章 goroutine和通道</h1>\n<h2>Go有两种并发编程的风格</h2>\n<pre><code>（1）CSP并发模式：goroutine+channel（如channel）\n（2）共享内存多线程的传统模型（如sync.Mutex）\n</code></pre>\n<ol>\n<li>当一个程序启动时，只有一个goroutine来调用main函数，称之为主goroutine。</li>\n<li>main函数返回时，所有的goroutine都暴力的直接终结。</li>\n<li>没有程序化的方法让一个goroutine来停止另一个，但是有办法和goroutine通信来要求它自己停止。</li>\n<li>channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</li>\n<li>channel是一个使用make创建的数据结构的引用，当复制或作为参数传递到一个函数时，复制的是引用，这样调用者和被调用者都引用同一份数据结构。</li>\n<li>和其他引用一样，channel的零值是nil。</li>\n<li>同种类型的channel可以使用==进行比较，channel也可以和nil进行比较。</li>\n</ol>\n<h2>发送、接收、关闭</h2>\n<ol>\n<li>通道主要有<strong>发送</strong> 和 <strong>接收</strong> 两个操作，两者统称为通信。</li>\n</ol>\n<pre><code>（1）发送  ch &#x3C;- data\n（2）接收  data = &#x3C;- ch  或 &#x3C;- ch （接收的结果不使用而直接丢弃也是允许的）\n</code></pre>\n<ol start=\"2\">\n<li>channel的第3种操作：关闭。</li>\n</ol>\n<pre><code>（1）在已经关闭的channel上进行发送操作将导致宕机\n（2）在已经关闭的channel上进行接收，将获取所有已经发送的值，直到channel为空\n（3）当关闭的channel被读完后，所有后续的接收操作都仍可进行，只是会取到通道元素类型对应的零值\n（4）可以使用ok语法来判断channel是否已关闭\ndata, ok := &#x3C;- ch\nif !ok {\n    // 说明channel已关闭且读完\n}\n（5）为了对（4）中的写法进行简化，可以用range语法循环对channel进行读取，range会不断从channel 接收值，直到它被关闭（close）。\n（6）主动关闭channel不是一个必须的操作，channel是可以自动回收的。只有在需要通知接收方goroutine所有的数据都发送完毕的时候，发送方才需要主动关闭channel。\n（7）GC是根据channel是否可以访问来决定是否回收它的，而不是根据它是否关闭。\n（8）关闭一个已经关闭的channel会导致宕机，关闭一个空channel(nil)也会导致宕机。\n（9）关闭channel还可以作为一个广播机制。\n</code></pre>\n<h2>无缓冲通道和缓冲通道</h2>\n<pre><code>ch = make(chan int)  //无缓冲通道\nch = make(chan int, 0)  //无缓冲通道\nch = make(chan int, 3)  //容量为3的缓冲通道\n</code></pre>\n<ol>\n<li>无缓冲通道的发送和接收会强制同步化，又称为同步通道。</li>\n<li>并发并不意味着事件一定同时发生，而是不能假设事件的先后顺序。</li>\n<li>缓冲通道的缓冲区，可以将发送和接收goroutine进行解耦。</li>\n<li>如果程序要知道通道的容量，可以使用内置的cap函数：</li>\n</ol>\n<blockquote>\n<p>fmt.Println(cap(ch))</p>\n</blockquote>\n<ol start=\"5\">\n<li>如果要获取当前通道内的元素个数，可以使用内置的len函数：</li>\n</ol>\n<blockquote>\n<p>fmt.Println(len(ch))\n因为在并发程序中这个信息会随着检索操作很快过时，所以它的价值很低，但是它在错误诊断和性能优化的时候很有用。</p>\n</blockquote>\n<ol start=\"6\">\n<li>粗暴的将缓冲通道作为队列在单个goroutine中使用是个错误。如果没有另一个goroutine从通道进行接收，发送者（也许是整个程序）有被永久阻塞的风险。如果仅仅需要一个简单的队列，使用slice创建一个即可。</li>\n<li>对于无缓冲的通道，如果因为没有goroutine接收时，会导致多个发送的goroutine被卡住，这叫做 ** goroutine泄露 **，这属于一个bug。不像回收变量，泄露的goroutine不会自动回收，所以确保goroutine在不再需要的时候可以自动结束。</li>\n</ol>\n<h2>单向通道</h2>\n<ol>\n<li>函数的channel形参有时会要求不能发送或不能接收，这样就可以避免在函数内部误用。</li>\n<li>chan &#x3C;- int 是只能往里写入的int类型通道，&#x3C;- chan int是一个只能从中读取的int类型通道。</li>\n<li>函数内违反单向通道使用原则的错误，会在编译时被检查出来。</li>\n<li>由于close操作只能在发送方操作，所以试图关闭一个只能接收的单向通道会引起编译时报错。</li>\n<li>在任何赋值操作中将双向通道转换为单向通道都是允许的，但是反过来是不行的。</li>\n</ol>\n<h2>并行循环</h2>\n<pre><code class=\"language-go\">func test() {\n    var wg sync.WaitGroup\n    for f := range filenames {\n        wg.Add(1)\n\n        //worker\n        go func(f string) {\n            defer wg.Done()\n            // do something\n        }(f)\n    }\n\n    wg.Wait()\n    // do other\n}\n</code></pre>\n<p>#第9章 使用共享变量实现并发</p>\n","date":"2017-10-02T10:00:00.000Z","title":"《Go程序设计语言》阅读","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["PHP"],"id":"modern-php-reading-notes","title":"《Modern PHP》阅读笔记","date":"2017-10-03T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false},"nextPost":{"summary":null,"tags":["工作"],"id":"tech-leader-team-management","title":"简谈技术Leader和团队管理","date":"2017-09-27T18:52:26.000Z","published":true,"hideInList":false,"feature":null,"isTop":false}},"__N_SSG":true}
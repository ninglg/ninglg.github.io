{"pageProps":{"post":{"summary":null,"tags":["算法"],"id":"search-algorithm","contentHtml":"<p>查找算法</p>\n<h1>二分查找</h1>\n<blockquote>\n<p>前提是数组有序，二分查找时间复杂度O(logN)</p>\n</blockquote>\n<pre><code class=\"language-go\">func BinarySearch(data []int, target int) int {\n\tvar low, high, mid int\n\tlow, high = 0, len(data) - 1\n\n\tfor low &#x3C;= high {\n\t\tmid = low + (high-low)/2    //防止溢出\n\n\t\tif data[mid] > target {\n\t\t\thigh = mid - 1\n\t\t} else if data[mid] &#x3C; target {\n\t\t\tlow = mid + 1\n\t\t} else {\n\t\t\treturn mid\n\t\t}\n\t}\n\n\treturn -1\n}\n</code></pre>\n<blockquote>\n<p>如果有序数组里面有重复数字，要查找重复数字的左右边界，可基于上述二分查找算法略加修改即可。\n如查找左边界：return mid 处改为 high=mid-1，return -1 处改为 return low。另外需要加一段判断left越界情况的逻辑 if left > len(data)-1 || data[left] != target 则return -1</p>\n</blockquote>\n<h1>TopK问题</h1>\n<h1>quick select 快速选择算法</h1>\n<blockquote>\n<p>quick select 算法的主要目的是在一个没有排序的数组里面，找到第k小的元素。\n快速选择的总体思路与快速排序一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从O(n log n)至O(n)，不过最坏情况仍然是O(n2)。</p>\n</blockquote>\n<pre><code class=\"language-go\">func quickselect(nums []int, start, end, k int) int {\n\t// use last element as pivot\n\tpivotIndex := partition(nums, start, end, end)\n\n\tif k-1 == pivotIndex {\n\t\treturn nums[pivotIndex]\n\t} else if k-1 > pivotIndex {\n\t\treturn quickselect(nums, pivotIndex+1, end, k)\n\t} else {\n\t\treturn quickselect(nums, start, pivotIndex-1, k)\n\t}\n}\n\nfunc partition(nums []int, start, end, pivot int) int {\n\t// move pivot to end\n\tnums[end], nums[pivot] = nums[pivot], nums[end]\n\tpivotValue := nums[end]\n\ti := start\n\tfor j := start; j &#x3C; end; j++ {\n\t\tif nums[j] > pivotValue {\n\t\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\t\ti++\n\t\t}\n\t}\n\t// move pivot to its sorted position\n\tnums[i], nums[end] = nums[end], nums[i]\n\t// return pivot index\n\treturn i\n}\n</code></pre>\n","date":"2010-10-20T10:00:00.000Z","title":"查找算法","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["算法"],"id":"sort-algorithm","title":"排序算法","date":"2010-10-20T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false},"nextPost":{"summary":null,"tags":["算法"],"id":"algorithm-time-complexity-cheat-sheet","title":"常用算法时间复杂度速查表","date":"2010-10-16T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false}},"__N_SSG":true}
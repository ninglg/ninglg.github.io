{"pageProps":{"post":{"summary":null,"tags":["Linux"],"id":"byte-order-big-endian-little-endian","contentHtml":"<p>此篇介绍一下字节序的概念。</p>\n<h2>字节序</h2>\n<p>字节序是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。</p>\n<h3>小端（Little-endian，小头）</h3>\n<p>将 <strong>低位字节</strong> 存储在起始地址(低地址)。</p>\n<h3>大端(Big-endian，大头)</h3>\n<p>将 <strong>高位字节</strong> 存储在起始地址(低地址)。</p>\n<blockquote>\n<p>即看低地址存储什么样的字节。</p>\n</blockquote>\n<h3>举例</h3>\n<ol>\n<li>Intel系列通常是小头字节序，Arm体系通常是大头序列。</li>\n<li>Java平台二进制读写一律采用大头字节序，网络上数据传输也都采用大头字节序。</li>\n<li>C++不跨平台，所以它的大小头依赖于系统架构。</li>\n<li>网络上通常采用 <strong>大头字节序</strong> ，所以大头字节序又叫 <strong>网络字节序</strong>。</li>\n<li>intel占据大量PC，都采用 <strong>小头字节序</strong> ，所以小头字节序又叫 <strong>主机字节序</strong>。</li>\n<li>字节序按应用场景也分两种，一是网络字节序，二是主机字节序。网络字节序为大端字节序，是确定的。主机字节序由 CPU 架构确定，可能是小端，也可能是大端，一般使用的 Intel 与 AMD 的 CPU 均为小端字节序。</li>\n</ol>\n<h1>Go判断大小端</h1>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"fmt\"\n\t\"unsafe\"\n)\n\nfunc IsLittleEndian() bool {\n\tn := 0x1234\n\tf := *((*byte)(unsafe.Pointer(&#x26;n)))\n\n\treturn (f ^ 0x34) == 0\n}\nfunc main() {\n\tfmt.Println(IsLittleEndian())\n}\n</code></pre>\n<blockquote>\n<p>注：Golang 是强类型语言，不允许不同类型的指针之间进行强制转化，因此需要借助 unsafe.Pointer 进行一次中转。</p>\n</blockquote>\n","date":"2011-01-10T10:00:00.000Z","title":"字节序：大端和小端","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["网络"],"id":"reserved-intranet-ip-addresses","title":"常见内网IP段","date":"2011-01-12T10:00:00.000Z","published":true,"hideInList":false,"feature":null},"nextPost":{"summary":null,"tags":["开发工具"],"id":"chrome-browser-dev-tool","title":"Chrome浏览器开发者工具","date":"2011-01-07T10:00:00.000Z","published":true,"hideInList":false,"feature":null}},"__N_SSG":true}
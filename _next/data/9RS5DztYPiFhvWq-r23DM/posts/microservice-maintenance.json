{"pageProps":{"post":{"summary":null,"tags":["微服务"],"id":"microservice-maintenance","contentHtml":"<h2>微服务带来的新问题</h2>\n<p>微服务架构虽然解决了一些单体应用的旧问题，但也引入了新的问题：</p>\n<ol>\n<li>微服务架构将整个应用分散成多个服务，定位故障点变得困难；</li>\n<li>服务数量变多，导致稳定性下降，并且其中一个服务故障可能导致整个系统挂掉；</li>\n<li>服务数量变多，部署和管理的工作量变大；</li>\n<li>开发方面：如何保证各个服务在持续开发的情况下仍然保持协同合作；</li>\n<li>测试方面：服务拆分后，几乎所有功能都会涉及多个服务，测试变得更加复杂。</li>\n</ol>\n<h2>微服务的维护手段</h2>\n<h3>监控：发现故障</h3>\n<h3>全链路跟踪：定位故障</h3>\n<p>要实现链路跟踪，每次服务调用会在HTTP的HEADERS中记录至少记录四项数据：</p>\n<ol>\n<li>traceId：traceId标识一个用户请求的调用链路，具有相同traceId的调用属于同一条链路。</li>\n<li>spanId：标识一次服务调用的ID，即链路跟踪的节点ID。</li>\n<li>parentId：父节点的spanId。</li>\n<li>requestTime &#x26; responseTime：请求时间和响应时间。</li>\n</ol>\n<p>关于链路跟踪的理论依据可详见Google的 Dapper。</p>\n<h3>日志：分析问题</h3>\n<h3>网关：权限控制，服务治理</h3>\n<h3>服务注册发现：动态扩容</h3>\n<h3>熔断、服务降级、限流</h3>\n<h3>测试粒度</h3>\n<h3>微服务框架</h3>\n<h3>Service Mesh</h3>\n<h3>Serverless、FaaS</h3>\n","date":"2018-01-11T00:00:00.000Z","title":"微服务架构的维护"},"prevPost":{"summary":null,"tags":["算法"],"id":"bloomfilter","title":"BloomFilter（布隆过滤器）介绍","date":"2018-01-15T00:00:00.000Z"},"nextPost":{"summary":null,"tags":["工作"],"id":"kpi-vs-okr","title":"目标管理方法：KPI和OKR","date":"2018-01-08T00:00:00.000Z"}},"__N_SSG":true}
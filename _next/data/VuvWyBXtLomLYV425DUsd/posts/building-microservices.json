{"pageProps":{"post":{"summary":null,"tags":["微服务"],"id":"building-microservices","contentHtml":"<h2>微服务</h2>\n<p>微服务就是一些协同工作的小而自治的服务。</p>\n<ul>\n<li>每个服务都很小，专注于做好一件事。</li>\n<li>服务之间均通过网络调用进行通信，从而加强了服务之间的隔离性，避免紧耦合。</li>\n</ul>\n<h3>微服务的好处</h3>\n<ul>\n<li>技术异构性</li>\n<li>弹性</li>\n<li>扩展</li>\n<li>简化部署</li>\n<li>与组织结构相匹配</li>\n<li>可组合性</li>\n<li>对可替代性的优化</li>\n</ul>\n<p><strong>没有银弹！</strong> 为了得到微服务的好处，需要在部署、测试和监控方面做很多的工作，还需要考虑如何扩展系统，并且保证它们的弹性，也还需要处理分布式事务或者与CAP相关的问题。</p>\n<p>很多组织采用微服务是为了使团队的自治性最大化。</p>\n<h2>演进式架构师</h2>\n<ul>\n<li>愿景、同理心、合作</li>\n<li>保证该系统适合开发人员在其上工作</li>\n<li>从更高的层次出发，理解如何做权衡</li>\n<li>治理和监督</li>\n</ul>\n<h2>如何建模服务</h2>\n<h3>好服务的标准</h3>\n<ul>\n<li>高内聚</li>\n<li>低耦合</li>\n</ul>\n<h2>集成</h2>\n<h3>微服务之间通信方式的选择非常多样化</h3>\n<ul>\n<li>SOAP</li>\n<li>XML-RPC</li>\n<li>REST</li>\n<li>Protocol Buffers</li>\n<li>Thrift</li>\n</ul>\n<h3>本地调用和远程调用并不相同</h3>\n<ul>\n<li>RPC的核心想法是隐藏远程调用的复杂性。使用本地调用不会引起性能问题，但是RPC会花大量的时间对负荷进行封装和解封装，更别提网络通信所需要的时间。</li>\n<li>需要注意的是，HTTP也可以用来实现RPC。比如SOAP就是基于HTTP进行路由的，但不幸的是它只用到HTTP很少的特性，而动词和HTTP的错误码都被忽略了。</li>\n<li>通过HTTP我们可以发送任何格式，甚至是二进制的。</li>\n</ul>\n<h3>实现基于事件的异步协作方式</h3>\n<h3>服务即状态机</h3>\n<h3>使用语义化的版本管理</h3>\n<ul>\n<li>MAJOR.MINOR.PATCH</li>\n<li>短期内同时使用两个版本的服务是合理的，尤其是当你做蓝绿部署或者金丝雀发布时</li>\n</ul>\n<h3>API组合</h3>\n<p>使用API入口（gateway）可以缓解移动设备与服务过多通信的问题，在这种模式下多个底层的调用会被聚合成为一个调用，当然它也有一定的局限性。</p>\n<h2>分解单块系统</h2>\n<ul>\n<li>最好考虑把哪部分代码抽取出去得到的收益最大，而不是为了抽取而抽取</li>\n<li>想要抽取出来的接口应该尽量少的被其它组件所依赖</li>\n<li>先分离数据库，再对服务进行分离</li>\n<li>重试保证最终一致性</li>\n<li>补偿事务</li>\n<li>分布式事务，事务管理器</li>\n</ul>\n<h2>部署</h2>\n<h3>真正理解CI的三个问题</h3>\n<ol>\n<li>每天签入代码到主干</li>\n<li>有一组测试来验证修改</li>\n<li>把修复CI当做第一优先级的事情来做</li>\n</ol>\n<h3>平台即服务</h3>\n<p>PaaS（Platform-as-a-Service）</p>\n<h3>传统的虚拟化技术</h3>\n<p>采用标准虚拟化的如AWS、VMWare、VSphere、Xen和KVM等。</p>\n<h3>基于轻量级容器的虚拟化（LXC）</h3>\n<p>Docker</p>\n<h2>测试</h2>\n<h3>单元测试</h3>\n<p>TDD：Test-Driven Development，测试驱动开发</p>\n<h3>Mock还是打桩</h3>\n<h3>金丝雀发布</h3>\n<ul>\n<li>金丝雀发布是指通过将部分生产流量引流到新部署的系统，来验证系统是否按预期执行。</li>\n<li>金丝雀发布与蓝/绿发布的不同之处在于，新旧版本共存的时间更长，而且经常会调整流量。</li>\n<li>Netflix广泛采用金丝雀发布的方式，通过对比新版本与基线版本的分数，只有当新版本分数更高时，才会全面部署新版本到生产环境。</li>\n</ul>\n<h3>平均修复时间胜过平均故障间隔时间</h3>\n<ul>\n<li>平均故障间隔时间（MTBF，Mean Time Between Failures）</li>\n<li>平均修复时间（MTTR，Mean Time To Repaire）</li>\n</ul>\n<h2>监控</h2>\n<p>监控小的服务，然后聚合起来看整体。</p>\n<h2>安全</h2>\n<ul>\n<li>单点登录SSO（Single Sign-On）</li>\n<li>HTTPS基本身份验证</li>\n<li>客户端证书TLS（Transport Layer Security，安全传输层协议）</li>\n<li>API秘钥\n不要实现自己的加密算法，不要发明自己的安全协议。</li>\n</ul>\n<h2>康威定律与系统设计</h2>\n<ul>\n<li>组织和架构应该一致，信奉这个理念的两个典范是Amazon和Netflix。</li>\n<li>每条业务线团队，负责自己创建的服务的整个生命周期，包括构建、测试、发布和运维，甚至弃用。</li>\n</ul>\n<h2>规模化微服务</h2>\n<p>当微服务的数量比人还多时，有什么应对的模式吗？</p>\n<ul>\n<li>故障无处不在\n除了使用流程和控制来试图阻止故障的发生外，更应该思考如何更加容易的在第一时间从故障中恢复过来。</li>\n<li>功能降级</li>\n<li>年度DiRT（Disaster Recovery Test，灾难恢复测试）</li>\n<li>超时、断路器</li>\n<li>幂等</li>\n<li>CQRS（Command-Query Responsibility Segregation，命令查询职责分离）模式，是一个存储和查询信息的替代模型。</li>\n</ul>\n<h3>缓存</h3>\n<ul>\n<li>客户端、代理和服务器端缓存</li>\n<li>HTTP缓存：</li>\n</ul>\n<ol>\n<li>cache-control</li>\n<li>expires</li>\n<li>etag（entity tags）</li>\n</ol>\n<h2>CAP定理</h2>\n<p>在分布式系统中，需要有三方面进行权衡：</p>\n<ol>\n<li>一致性（consistency）</li>\n<li>可用性（availability）</li>\n<li>分区容忍性（partition tolerance）\n如果系统没有分区容忍性，就不能跨网络运行。换句话说，需要在本地运行一个单独的进程。所以，CA系统在分布式系统中根本是不存在的。选择AP还是CP，在现实中要视情况而定。</li>\n</ol>\n<h2>服务发现</h2>\n<h2>动态服务注册</h2>\n<ul>\n<li>Zookeeper</li>\n<li>Consul</li>\n</ul>\n<h2>总结</h2>\n<ul>\n<li>围绕业务概念建模</li>\n<li>接受自动化文化</li>\n<li>隐藏内部实现细节</li>\n</ul>\n","date":"2017-07-20T00:00:00.000Z","title":"微服务设计"},"prevPost":{"summary":null,"tags":["Docker"],"id":"docker-intro","title":"Docker原理介绍","date":"2017-07-22T00:00:00.000Z"},"nextPost":{"summary":null,"tags":["电影"],"id":"iron-man","title":"钢铁侠","date":"2017-06-27T00:00:00.000Z"}},"__N_SSG":true}
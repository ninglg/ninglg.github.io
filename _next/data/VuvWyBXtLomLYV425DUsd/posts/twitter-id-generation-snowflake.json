{"pageProps":{"post":{"summary":null,"tags":["系统设计"],"id":"twitter-id-generation-snowflake","contentHtml":"<h2>一些传统ID生成方式的弊端</h2>\n<p><strong>1. 内置随机ID函数</strong>\n一些语言内置的随机ID生成函数，存在着生成的ID位数过长，ID无序导致入库性能较差等问题。\n另外，如果是UUID的生成方式，则需基于机器MAC地址，有安全风险，且不是分布式的。</p>\n<p><strong>2. 数据库自增主键</strong>\n严重依赖数据库，性能不高，可用性也有风险。</p>\n<p><strong>3. Redis的INCR方案</strong>\nQPS测算在20W+左右，如果超过这个范围则不合适。</p>\n<h2>SnowFlake算法</h2>\n<p>SnowFlake是Twitter公司所采用的一种算法，目的是在分布式系统中生成全局唯一且趋势递增的ID。</p>\n<p><img src=\"https://ninglg.com/post-images/1565092711034.jpg\" alt=\"\"></p>\n<ol>\n<li>第1位代表符号位，始终为0；</li>\n<li>第2组代表时间戳，精确到毫秒；</li>\n<li>第3组代表工作机器id，高5位是datacenterId，低5位是workerId；</li>\n<li>第4组代表序列号，这个值在同一毫秒同一节点上从0开始不断累加；</li>\n</ol>\n<blockquote>\n<p>理论上SnowFlake方案可达到的QPS约为409.6w/s。</p>\n</blockquote>\n<h2>SnowFlake的优缺点</h2>\n<h3>优点</h3>\n<ol>\n<li>内存生成，不依赖外部DB，确保高性能高可用。</li>\n<li>生成的ID呈趋势递增，在插入索引树时表现性能较好。</li>\n</ol>\n<h3>缺点</h3>\n<ol>\n<li>依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。</li>\n<li>为了解决时钟问题，有些公司采用ZK去比较当前workerId也就是节点ID使用的时间是否有回拨，如果有回拨就进行休眠固定时间，看是否能赶上时间。如果能赶上的话，就继续生成ID。如果一直没有赶上达到某个值的话，就报错处理。</li>\n</ol>\n<h2>业务对ID号的需求</h2>\n<ol>\n<li>全局唯一性\n这是ID生成的天然需求。</li>\n<li>趋势/单调递增\n为了保证系统（如DB）写入的性能。</li>\n<li>信息安全\n防止关键业务信息（如订单量）被竞对根据ID数量计算出来。</li>\n</ol>\n<p>如果感兴趣，也可以看下美团点评的分布式ID生成系统（Leaf）的实现，其中使用了一些缓存策略，提高了性能和稳定性。</p>\n","date":"2017-11-16T00:00:00.000Z","title":"Twitter的分布式ID生成算法SnowFlake"},"prevPost":{"summary":null,"tags":["算法"],"id":"paxos-and-raft-consistency-algorithm-in-distributed-system","title":"分布式中的一致性算法：Paxos和Raft","date":"2017-11-27T00:00:00.000Z"},"nextPost":{"summary":null,"tags":["微服务"],"id":"service-avalanche-degradation-current-limiting-and-dissolution","title":"服务雪崩、降级、限流与熔断","date":"2017-11-06T00:00:00.000Z"}},"__N_SSG":true}
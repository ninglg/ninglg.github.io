{"pageProps":{"post":{"summary":null,"tags":["Golang"],"id":"golang-conditional-compilation-and-cross-compilation","contentHtml":"<h1>编译选项go tool</h1>\n<h2>go tool compile -S main.go</h2>\n<blockquote>\n<p>输出汇编内容</p>\n</blockquote>\n<p>指令集 -gcflags 用于将标识参数传递给 Go 编译器，如下：</p>\n<pre><code>-m 会打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 -m，但是信息量较大，一般用 1 个就可以了。\n-l 会禁用函数内联，在这里禁用掉 inline 能更好的观察逃逸情况，减少干扰。\n为了避免编译器的优化，加上-gcflags '-l -N'选项，-gcflags是给编译器的选项，通过go tool compile可以看到选项列表，-l表示禁止内联，-N表示禁止优化。一般要看一些细节的时候，都需要把这两个选项带上。\n</code></pre>\n<blockquote>\n<p>$ go build -gcflags '-N -l -m' main.go</p>\n</blockquote>\n<p>还通过反编译命令查看</p>\n<blockquote>\n<p>$ go tool compile -S main.go\n可以通过 go tool compile -help 查看所有允许传递给编译器的标识参数。\n直接通过 go build -gcflags '-m -l' 就可以看到逃逸分析的过程和结果。</p>\n</blockquote>\n<p>在一个函数上方增加一行  //go:noinline  编译指令，可以用来阻止编译器内联此函数。如果用 -gcflags='-l -N' 选项，则是在全局范围内禁止优化。</p>\n<p>编译器对于内联操作的优化，是递归操作的，可以逐层往上层调用方进行内联。</p>\n<h1>Go二进制中注入编译信息</h1>\n<h2>main.go</h2>\n<pre><code class=\"language-go\">package main\n\nimport (\n\t\"fmt\"\n)\n\nvar (\n\tAppName      string // 应用名称\n\tAppVersion   string // 应用版本\n\tBuildVersion string // 编译版本\n\tBuildTime    string // 编译时间\n\tGitRevision  string // Git版本\n\tGitBranch    string // Git分支\n\tGoVersion    string // Golang信息\n)\n\nfunc main() {\n\tVersion()\n\t// 业务代码入口\n}\n\n// Version 版本信息\nfunc Version() {\n\tfmt.Printf(\"App Name:\\t%s\\n\", AppName)\n\tfmt.Printf(\"App Version:\\t%s\\n\", AppVersion)\n\tfmt.Printf(\"Build version:\\t%s\\n\", BuildVersion)\n\tfmt.Printf(\"Build time:\\t%s\\n\", BuildTime)\n\tfmt.Printf(\"Git revision:\\t%s\\n\", GitRevision)\n\tfmt.Printf(\"Git branch:\\t%s\\n\", GitBranch)\n\tfmt.Printf(\"Golang Version: %s\\n\", GoVersion)\n}\n</code></pre>\n<h2>编译脚本build.sh</h2>\n<pre><code class=\"language-sh\">#!/bin/bash\nset -e\n\nPROJECT_NAME=\"myprogram.com\"\nBINARY=\"myprogram\"\n\nOUTPUT_DIR=output\nGOOS=$(go env GOOS)\n\nAPP_NAME=${PROJECT_NAME}\nAPP_VERSION=$(git log -1 --oneline)\nBUILD_VERSION=$(git log -1 --oneline)\nBUILD_TIME=$(date \"+%FT%T%z\")\nGIT_REVISION=$(git rev-parse --short HEAD)\nGIT_BRANCH=$(git name-rev --name-only HEAD)\nGO_VERSION=$(go version)\n\nCGO_ENABLED=0 go build -a -installsuffix cgo -v \\\n-ldflags \"-s -X 'main.AppName=${APP_NAME}' \\\n            -X 'main.AppVersion=${APP_VERSION}' \\\n            -X 'main.BuildVersion=${BUILD_VERSION}' \\\n            -X 'main.BuildTime=${BUILD_TIME}' \\\n            -X 'main.GitRevision=${GIT_REVISION}' \\\n            -X 'main.GitBranch=${GIT_BRANCH}' \\\n            -X 'main.GoVersion=${GO_VERSION}'\" \\\n-o ${OUTPUT_DIR}/${BINARY} main.go\n</code></pre>\n","date":"2017-10-28T00:00:00.000Z","title":"Go程序的条件编译和交叉编译"},"prevPost":{"summary":null,"tags":["微服务"],"id":"service-avalanche-degradation-current-limiting-and-dissolution","title":"服务雪崩、降级、限流与熔断","date":"2017-11-06T00:00:00.000Z"},"nextPost":{"summary":null,"tags":["微服务"],"id":"service-discovery-in-microservices","title":"微服务中的服务发现","date":"2017-10-18T00:00:00.000Z"}},"__N_SSG":true}
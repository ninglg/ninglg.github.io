{"pageProps":{"post":{"summary":null,"tags":["Golang"],"id":"go-command-line-os-args-flag","contentHtml":"<h2>os.Args</h2>\n<pre><code class=\"language-js\">package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main () {\n    for idx, arg := range os.Args {\n        fmt.Println(\"参数\", idx, \":\", arg)\n    }\n}\n</code></pre>\n<p>然后执行go build main.go生成可执行文件：</p>\n<blockquote>\n<p>./main -v 1.0 bbb 222</p>\n</blockquote>\n<p>得到输出：</p>\n<pre><code class=\"language-text\">参数 0 : ./main\n参数 1 : -v\n参数 2 : 1.0\n参数 3 : bbb\n参数 4 : 222\n</code></pre>\n<p>os.Args用法说明：</p>\n<ol>\n<li>命令行的第一个参数默认是程序路径本身</li>\n<li>os.Args的类型是[]string，也就是字符串切片</li>\n<li>os.Args可以用for..range遍历</li>\n<li>可以用len(os.Args)来获取全部参数的数量</li>\n<li>如果不想要输出os.Args的第一个值，可以使用os.Args[1:]</li>\n</ol>\n<h2>flag</h2>\n<pre><code class=\"language-js\">package main\nimport (\n    \"fmt\"\n    \"flag\"\n)\n\nvar b = flag.Bool(\"b\", false, \"bool类型参数\")\nvar s = flag.String(\"s\", \"\", \"string类型参数\")\n\nfunc main() {\n    flag.Parse()\n    fmt.Println(\"-b:\", *b)\n    fmt.Println(\"-s:\", *s)\n    fmt.Println(\"其他参数：\", flag.Args())\n}\n</code></pre>\n<blockquote>\n<p>go run main.go</p>\n</blockquote>\n<pre><code class=\"language-text\">-b: false\n-s:\n其他参数： []\n</code></pre>\n<blockquote>\n<p>go run main.go -b</p>\n</blockquote>\n<pre><code class=\"language-text\">-b: true\n-s:\n其他参数： []\n</code></pre>\n<blockquote>\n<p>go run main.go -b -s test others</p>\n</blockquote>\n<pre><code class=\"language-text\">-b: true\n-s: test\n其他参数： [others]\n</code></pre>\n<blockquote>\n<p>go run main.go -help</p>\n</blockquote>\n<pre><code class=\"language-text\">Usage of /var/folders/6q/s3nht_hx0bn54d8nx031lfnr0000gn/T/go-build965629684/b001/exe/main:\n  -b\tbool类型参数\n  -s string\n    \tstring类型参数\nexit status 2\n</code></pre>\n<p>flag用法说明：</p>\n<ol>\n<li>使用flag包，首先定义待解析的命令行参数，也就是以\"-\"开头的参数</li>\n<li>-help不需要特别指定，可以自动处理</li>\n<li>通过flag.Bool和flag.String，建立了2个指针b和s，分别指向bool类型和string类型的变量，要通过 *b 和 *s 使用变量值</li>\n<li>flag.Bool和flag.String的参数有3个，分别是命令行参数名称，默认值，提示字符串</li>\n<li>flag使用前，必须先用flag.Parse()解析</li>\n<li>参数中没有能够按照预定义的参数解析的部分，可通过flag.Args()获取，这是一个字符串切片。需要注意的是，从第一个不能解析的参数开始，后面的所有参数都是无法解析的，即使后面的参数中含有预定义的参数</li>\n<li>flag.PrintDefaults()可以打印出类似-help的效果</li>\n<li>flag.NArg()代表命令行参数的个数</li>\n<li>flag.Usage()代表用法说明</li>\n<li>参数也可以这样绑定：</li>\n</ol>\n<blockquote>\n<p>flag.BoolVar(&#x26;h, \"h\", false, \"this help\")</p>\n</blockquote>\n<ol start=\"11\">\n<li>命令行语法主要有以下几种形式：</li>\n</ol>\n<pre><code class=\"language-text\">-flag //只支持bool类型\n-flag=x\n-flag x //只支持非bool类型\n</code></pre>\n","date":"2015-06-01","title":"Go语言的命令行参数os.Args和flag包"},"prevPost":{"summary":null,"tags":["Kafka"],"id":"use-kafka-on-mac-system","title":"在Mac系统上使用Kafka环境","date":"2015-06-05"},"nextPost":{"summary":null,"tags":["微服务"],"id":"command-query-event-cqrs-intro","title":"命令查询职责分离(CQRS)模式介绍","date":"2015-05-29"}},"__N_SSG":true}
{"pageProps":{"post":{"summary":null,"tags":["数据结构"],"id":"binary-tree-intro","contentHtml":"<p>数据结构：二叉树</p>\n<h1>二叉树的特点</h1>\n<ol>\n<li>二叉树中每个节点最多有两棵子树，称为左子树、右子树；</li>\n<li>左子树和右子树是有顺序的，有左右之分，次序不能随意颠倒；</li>\n<li>即使某个节点只有一个子树，也要区分左右子树。</li>\n</ol>\n<blockquote>\n<p>即：最多两棵树，还要分左右。</p>\n</blockquote>\n<ol start=\"4\">\n<li>完全二叉树：只有底层没满，且按顺序排列在左边的二叉树。</li>\n<li>满二叉树：所有节点都满了的二叉树</li>\n<li>二叉搜索树：节点分大小，左边>中间>右边。</li>\n<li>平衡二叉树：左右子树的高度差最大为1。</li>\n<li>平衡二叉搜索树：集合二叉搜索树和平衡二叉树两者特点的树，比如AVL树。</li>\n</ol>\n<h1>二叉树的存储</h1>\n<pre><code class=\"language-go\"> type TreeNode struct {\n     Val int\n     Left *TreeNode\n     Right *TreeNode\n }\n</code></pre>\n<h1>树的遍历</h1>\n<h2>前序遍历</h2>\n<h3>前序遍历-递归</h3>\n<pre><code class=\"language-go\">func preOrder(t *TreeNode) {\n\tif t == nil {\n\t\treturn\n\t}\n\tfmt.Println(t.Val)\n\tpreOrder(t.Left)\n\tpreOrder(t.Right)\n}\n</code></pre>\n<h3>前序遍历-非递归</h3>\n<h2>中序遍历</h2>\n<h3>中序遍历-递归</h3>\n<pre><code class=\"language-go\">func inOrder(t *TreeNode) {\n\tif t == nil {\n\t\treturn\n\t}\n\tinOrder(t.Left)\n\tfmt.Println(t.Val)\n\tinOrder(t.Right)\n}\n</code></pre>\n<h3>中序遍历-非递归</h3>\n<pre><code class=\"language-go\">// 使用栈来记录树上的节点，栈顶的节点即是当前访问的节点\n</code></pre>\n<h2>后序遍历</h2>\n<h3>后序遍历-递归</h3>\n<pre><code class=\"language-go\">func postOrder(t *TreeNode) {\n\tif t == nil {\n\t\treturn\n\t}\n\tpostOrder(t.Left)\n\tpostOrder(t.Right)\n\tfmt.Println(t.Val)\n}\n</code></pre>\n<h3>后序遍历-非递归</h3>\n<h1>DFS和BFS搜索</h1>\n<p><img src=\"https://ninglg.com/post-images/1646830336745.gif\" alt=\"\"></p>\n<h2>广度优先搜索（Breath First Search，BFS，又称层序遍历。一般采用队列进行遍历辅助。）</h2>\n<pre><code class=\"language-go\">func bfs(p *TreeNode) []int {\n\tres := make([]int, 0)\n\tif p == nil {\n\t\treturn res\n\t}\n\n// BFS需要使用一个 **队列** 协助，此处用slice模拟队列\n\tqueue := []*TreeNode{p}\n\tfor len(queue) > 0 {    //每一轮是不同层\n\t\tlength := len(queue)\n\t\tfor length > 0 {    // 同层遍历\n\t\t\tlength--\n\t\t\tif queue[0].Left != nil {\n\t\t\t\tqueue = append(queue, queue[0].Left)\n\t\t\t}\n\t\t\tif queue[0].Right != nil {\n\t\t\t\tqueue = append(queue, queue[0].Right)\n\t\t\t}\n\t\t\tres = append(res, queue[0].Val)\n\t\t\tqueue = queue[1:]\n\t\t}\n\t}\n\n\treturn res\n}\n\n</code></pre>\n<h2>深度优先搜索（Depth First Search，DFS。一般采用栈进行遍历辅助，可用递归来实现栈。）</h2>\n<pre><code class=\"language-go\">func DFS(root *TreeNode) []int {\n    if root == nil {\n        return\n    }\n\n    var res []int\n    res = append(res, root.Val)\n\n    DFS(root.Left)\n    DFS(root.Right)\n\n    return res\n}\n</code></pre>\n<h1>计算二叉树的节点个数</h1>\n<pre><code class=\"language-go\">/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc countNodes(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n\n    return countNodes(root.Left) + countNodes(root.Right) + 1\n}\n</code></pre>\n<h1>计算二叉树的深度</h1>\n<pre><code class=\"language-go\">func maxDepth(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n\n    return 1 + max(maxDepth(root.Left), maxDepth(root.Right))\n}\n\nfunc max(x,y int) int {\n    if x > y {\n        return x\n    }\n    \n    return y\n}\n</code></pre>\n<h1>平衡二叉树</h1>\n<h2>判断一棵二叉树是否是平衡二叉树</h2>\n<pre><code class=\"language-go\">func isBalanced(root *TreeNode) bool {\n\tif root == nil {\n\t\treturn true\n\t}\n\tleftHeight := height(root.Left)\n\trightHeight := height(root.Right)\n\tif leftHeight-rightHeight &#x3C; -1 || leftHeight-rightHeight > 1 {\n\t\treturn false\n\t}\n\n\treturn isBalanced(root.Left) &#x26;&#x26; isBalanced(root.Right)\n}\n\nfunc height(node *TreeNode) int {\n\tif node == nil {\n\t\treturn 0\n\t}\n\n\treturn 1 + max(height(node.Left), height(node.Right))\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\n\treturn b\n}\n</code></pre>\n<h2>合并两个二叉树</h2>\n<pre><code class=\"language-go\">func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {\n\tif root1 == nil &#x26;&#x26; root2 == nil {\n\t\treturn nil\n\t} else if root1 == nil {\n\t\treturn root2\n\t} else if root2 == nil {\n\t\treturn root1\n\t} else {\n\t\troot1.Val += root2.Val\n\t\troot1.Left = mergeTrees(root1.Left, root2.Left)\n\t\troot1.Right = mergeTrees(root1.Right, root2.Right)\n\t\treturn root1\n\t}\n}\n</code></pre>\n<h2>反转二叉树</h2>\n<pre><code class=\"language-go\">/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc invertTree(root *TreeNode) *TreeNode {\n    if root == nil {\n        return nil\n    }\n\n    left := invertTree(root.Left)\n    right := invertTree(root.Right)\n\n    root.Left = right\n    root.Right = left\n    \n    return root\n}\n</code></pre>\n<h2>判断两棵二叉树是否相同</h2>\n<pre><code class=\"language-go\">/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n    if (p == nil) &#x26;&#x26; (q == nil) {\n        return true\n    }\n\n    if (p == nil) || (q == nil) {\n        return false\n    }\n\n    if p.Val != q.Val {\n        return false\n    }\n\n    return isSameTree(p.Left, q.Left) &#x26;&#x26; isSameTree(p.Right, q.Right)    \n}\n</code></pre>\n<h2>打印二叉树的所有路径</h2>\n<blockquote>\n<p>输入：root = [1,2,3,null,5]\n输出：[\"1->2->5\",\"1->3\"]</p>\n</blockquote>\n<pre><code class=\"language-go\">/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nvar paths []string\n\nfunc binaryTreePaths(root *TreeNode) []string {\n    paths = []string{}\n    constructPaths(root, \"\")\n    return paths\n}\n\nfunc constructPaths(root *TreeNode, path string) {\n    if root != nil {\n        pathSB := path\n        pathSB += strconv.Itoa(root.Val)\n        if root.Left == nil &#x26;&#x26; root.Right == nil {\n            paths = append(paths, pathSB)\n        } else {\n            pathSB += \"->\"\n            constructPaths(root.Left, pathSB)\n            constructPaths(root.Right, pathSB)\n        }\n    }\n}\n</code></pre>\n<h2>计算二叉树的最小深度</h2>\n<blockquote>\n<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>\n</blockquote>\n<pre><code class=\"language-go\">/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc minDepth(root *TreeNode) int {\n    if root == nil {\n\t\treturn 0\n\t}\n\n\tif root.Left == nil {\n\t\treturn minDepth(root.Right) + 1\n\t}\n\n\tif root.Right == nil {\n\t\treturn minDepth(root.Left) + 1\n\t}\n\n\treturn min(minDepth(root.Left), minDepth(root.Right)) + 1  \n}\n\nfunc min(a, b int) int {\n    if a &#x3C; b {\n        return a\n    }\n\n    return b\n}\n</code></pre>\n<h2>二叉树的最近公共祖先</h2>\n<pre><code class=\"language-go\">/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n    if root == nil {\n        return nil\n    }\n\n    if root.Val == p.Val || root.Val == q.Val {\n        return root\n    }\n\n    left := lowestCommonAncestor(root.Left, p, q)\n    right := lowestCommonAncestor(root.Right, p, q)\n    if left != nil &#x26;&#x26; right != nil {\n        return root\n    }\n\n    if left == nil {\n        return right\n    }\n    \n    return left\n}\n</code></pre>\n<h2>判断是否是轴对称的对称二叉树</h2>\n<pre><code class=\"language-go\">/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isSymmetric(root *TreeNode) bool {\n    if root == nil {\n        return true\n    }\n\n    return compare(root.Left, root.Right)\n}\n\nfunc compare(node1 *TreeNode, node2 *TreeNode) bool {\n    if node1 == nil &#x26;&#x26; node2 == nil {\n        return true\n    }\n\n    if node1 == nil || node2 == nil {\n        return false\n    }\n\n    if node1.Val != node2.Val {\n        return false\n    }\n\n\n    return compare(node1.Left, node2.Right) &#x26;&#x26; compare(node1.Right, node2.Left)\n}\n</code></pre>\n<h1>二分搜索树（BST，Binary Search Tree）</h1>\n<ol>\n<li>二分搜索树也是一种二叉树，但二分搜索树种每个节点的值都要大于其左子树所有节点的值，小于其右子树所有节点的值；</li>\n<li>每一棵子树也是二分搜索树。</li>\n</ol>\n<h2>验证是否是二叉搜索树</h2>\n<pre><code class=\"language-go\">/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isValidBST(root *TreeNode) bool {\n    if root == nil{\n        return true\n    }\n    var stack []*TreeNode\n    cur := root\n    var prev *TreeNode\n    \n    for len(stack)>0 || cur!=nil{\n        if cur!=nil{\n            stack = append(stack,cur)\n            cur = cur.Left\n        }else{\n            cur = stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n            if prev!=nil &#x26;&#x26;prev.Val >= cur.Val{\n                return false\n            }\n            \n            prev = cur\n            cur = cur.Right\n        }\n    }\n    \n    return true\n}\n</code></pre>\n<h1>平衡二叉树（AVL树、红黑树）</h1>\n<h1>线段树</h1>\n<h1>Trie树（又称字典树或前缀树）</h1>\n","date":"2011-03-20T10:00:00.000Z","title":"数据结构：二叉树","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["Linux"],"id":"linux-process-communication","title":"Linux进程间的通信机制","date":"2011-09-14T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false},"nextPost":{"summary":null,"tags":["Linux"],"id":"sed-command-usage","title":"sed命令使用","date":"2011-03-16T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false}},"__N_SSG":true}
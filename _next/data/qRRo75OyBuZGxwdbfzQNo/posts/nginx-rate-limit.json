{"pageProps":{"post":{"summary":null,"tags":["Nginx"],"id":"nginx-rate-limit","contentHtml":"<p>此篇介绍一下Nginx的限流功能。</p>\n<h2>Nginx限流方式</h2>\n<ol>\n<li>限制访问频率</li>\n<li>限制并发连接数</li>\n</ol>\n<h2>一、限制访问频率</h2>\n<h3>1. 正常流量限制访问频率</h3>\n<p>在nginx.conf配置文件中可以使用limit_req_zone命令及limit_req命令限制单个IP的请求处理频率。</p>\n<blockquote>\n<p>limit_req_zone key zone rate</p>\n</blockquote>\n<pre><code>key: 定义需要限流的对象\nzone: 定义共享内存区来存储访问信息\nrate: 用于设置最大访问速率\n</code></pre>\n<p>示例如：</p>\n<pre><code>http {\n    limit_req_zone $binary_remote_addr zone=myLimit:10m rate=3r/s;\n}\nserver {\n    location / {\n        limit_req zone=myLimit;\n        rewrite / http://www.test.com permanent;\n        }\n}\n</code></pre>\n<h3>2. 突发流量限制访问频率</h3>\n<p>上面的配置在一定程度上可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动高峰时的突发流量，这时候应该如何处理呢？Nginx提供了burst参数结合nodelay参数可以解决流量突发的问题，即设置在超过请求数外能额外处理的请求数。示例如：</p>\n<pre><code>http {\n    limit_req_zone $binary_remote_addr zone=myLimit:10m rate=3r/s;\n}\n\nserver {\n    location / {\n        limit_req zone=myLimit burst=5 nodelay;\n        rewrite / http://www.test.com permanent;\n        }\n}\n</code></pre>\n<p>可以看到上面添加了burst=5 nodelay。\n如果没有添加nodelay参数，则可以理解为预先在内存中占用了5个请求的位置，如果有5个突发请求就会按照200ms/个去依次处理请求，也就是1s内把5个请求全部处理完毕。如果1s内有新的请求到达也不会立即进行处理，因为紧急程度更低。这样实际上就会将额外的5个突发请求以200ms/个去依次处理，保证了处理速率的稳定，所以在处理突发流量的时候也一样可以正常处理。\n如果添加了nodelay参数则表示要立即处理这5个突发请求。</p>\n<h2>二、限制并发连接数</h2>\n<p>Nginx中的ngx_http_limit_conn_module模块提供了限制并发连接数的功能，可以使用limit_conn_zone指令以及limit_conn执行进行配置。接下来我们可以通过一个简单的例子来看下：</p>\n<pre><code>http {\n    limit_conn_zone $binary_remote_addr zone=myip:10m;\n    limit_conn_zone $server_name zone=myServerName:10m;\n}\n\nserver {\n    location / {\n        limit_conn myip 10;\n        limit_conn myServerName 100;\n        rewrite / http://www.test.com permanent;\n        }\n}\n</code></pre>\n<p>上面配置了单个IP同时并发连接数最多只能10个连接，并且设置了整个虚拟服务器同时最大并发数最多只能100个链接。当然，只有当请求的header被服务器处理后，虚拟服务器的连接数才会计数。</p>\n<p>Nginx是基于漏桶算法原理实现的，实际上限流一般都是基于漏桶算法和令牌桶算法实现的。接下来我们来看看关于这两个算法的介绍：</p>\n<h2>三、令牌桶算法</h2>\n<p>令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limit）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。</p>\n<p>令牌桶算法的机制如下：存在一个大小固定的令牌桶，会以恒定的速率源源不断产生令牌。如果令牌消耗速率小于生产令牌的速度，令牌就会一直产生直至装满整个令牌桶。</p>\n<h2>四、漏桶算法</h2>\n<p>漏桶（Leaky Bucket）算法也是网络世界中流量整形或速率限制时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。</p>\n<p>漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。突发流量会进入到一个漏桶，漏桶会按照我们定义的速率依次处理请求，如果水流过大也就是突发流量过大就会直接溢出，即多余的请求会被拒绝，所以漏桶算法能控制数据的传输速率。</p>\n<pre><code>令牌桶算法与漏桶算法的区别：两种算法都能够限制数据传输速率，但令牌桶还允许某种程度的突发传输。因为令牌桶算法只要令牌桶中存在令牌，就可以突发的传输对应的数据到目的地，所以更适合流量突发的情形下进行使用。\n1. 漏桶是出，令牌是进\n2. 令牌是允许伸缩的\n</code></pre>\n","date":"2014-10-15T10:00:00.000Z","title":"Nginx限流功能介绍","published":true,"hideInList":false,"feature":null,"isTop":false},"prevPost":{"summary":null,"tags":["Nginx"],"id":"nginx-load-balance-4-level-7-level","title":"Nginx的四层负载均衡和七层负载均衡","date":"2014-12-05T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false},"nextPost":{"summary":null,"tags":["Redis"],"id":"redis-develop-guideline","title":"Redis开发规范","date":"2014-10-03T10:00:00.000Z","published":true,"hideInList":false,"feature":null,"isTop":false}},"__N_SSG":true}
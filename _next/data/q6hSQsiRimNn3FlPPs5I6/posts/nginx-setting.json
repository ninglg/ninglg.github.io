{"pageProps":{"post":{"summary":null,"tags":["Nginx"],"id":"nginx-setting","contentHtml":"<h1>规则</h1>\n<h2>nginx命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>nginx -s stop/reload/quit</td>\n<td>停止/重新加载配置文件/平滑停止Nginx服务</td>\n</tr>\n<tr>\n<td>nginx -t</td>\n<td>测试配置文件是否正确</td>\n</tr>\n<tr>\n<td>nginx -v</td>\n<td>显示 Nginx 版本信息</td>\n</tr>\n<tr>\n<td>nginx -V</td>\n<td>显示 Nginx 版本信息、编译器和配置参数的配置</td>\n</tr>\n</tbody>\n</table>\n<h2>proxy_pass</h2>\n<ol>\n<li>配置反向代理的路径。</li>\n<li>需要注意的是如果 proxy_pass 的 url 最后为 /，则表示绝对路径，否则（不含变量下）表示相对路径，所有的路径都会被代理过去。</li>\n</ol>\n<h2>upstream</h2>\n<p>配置负载均衡，upstream 默认是以<strong>轮询</strong>的方式进行负载，另外还支持四种模式，分别是：</p>\n<ol>\n<li>weight：权重，指定轮询的概率，weight 与访问概率成正比</li>\n<li>ip_hash：按照访问 IP 的 hash 结果值分配</li>\n<li>fair：按后端服务器响应时间进行分配，响应时间越短优先级别越高</li>\n<li>url_hash：按照访问 URL 的 hash 结果值分配</li>\n</ol>\n<h2>Location优先级</h2>\n<table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>~</td>\n<td>执行一个正则匹配，区分大小写</td>\n</tr>\n<tr>\n<td>~*</td>\n<td>执行一个正则匹配，不区分大小写</td>\n</tr>\n<tr>\n<td>^~</td>\n<td>普通字符匹配。使用前缀匹配。如果匹配成功，则不再匹配其他location。</td>\n</tr>\n<tr>\n<td>=</td>\n<td>进行普通字符精确匹配。也就是完全匹配</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>优先级和在nginx配置中location的顺序没有太大关系，而与location表达式的类型有关。相同类型的表达式，字符串长的会优先匹配。</p>\n</blockquote>\n<pre><code>1. 等号类型（=）的优先级最高。一旦匹配成功，则不再查找其他匹配项。\n2. ^~类型表达式。一旦匹配成功，则不再查找其他匹配项。\n3. 正则表达式类型（~、~*）的优先级次之。如果有多个location的正则能匹配的话，则使用正则表达式最长的那个。\n4. 常规字符串匹配类型，按前缀匹配。\n</code></pre>\n<h1>示例</h1>\n<p>user nobody; #配置用户或者组，默认为nobody nobody</p>\n<p>worker_processes 4; #允许生成的进程数，默认为1</p>\n<p>worker_cpu_affinity 00000001 00000010 00000100 00001000; #为每个进程分配一个CPU</p>\n<p>worker_rlimit_nofile 102400; #为nginx工作进程改变打开最多文件描述符数目的限制。用来在不重启主进程的情况下增加限制。</p>\n<p>error_log logs/error.log;</p>\n<p>error_log logs/error.log notice;</p>\n<p>error_log logs/error.log info; #指定日志路径，级别。这个设置可以放入全局块，http块，server块，级别依次为：debug|info|notice|warn|error|crit|alert|emerg</p>\n<p>pid logs/nginx.pid; #指定nginx进程运行文件存放地址</p>\n<p>events {</p>\n<p>accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on</p>\n<p>multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off</p>\n<p>use epoll; #使用epoll（linux2.6的高性能方式）事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</p>\n<p>worker_connections 102400; #最大连接数，默认为512</p>\n<p>}</p>\n<p>http {</p>\n<p>include mime.types; #文件扩展名与文件类型映射表</p>\n<p>default_type application/octet-stream; #默认文件类型，默认为text/plain</p>\n<p>lua_package_path \"/usr/local/lib/lua/?.lua;;\"; #lua库位置</p>\n<p>charset utf-8; #字符集</p>\n<p>server_names_hash_bucket_size 128; # 保存服务器名字的hash表</p>\n<p>client_header_buffer_size 4k; #用来缓存请求头信息的，容量4K，如果header头信息请求超过了且没有配置client_header_buffer_size，nginx会直接返回400错误</p>\n<p>large_client_header_buffers 4 32k; #如果large_buffer还是无法容纳，那么就会返回414（处理request_line）/400（处理request_header）错误</p>\n<p>client_max_body_size 300m; #允许客户端请求的最大单文件字节数</p>\n<p>tcp_nodelay on; #提高数据的实时响应性</p>\n<p>client_body_buffer_size 512k; #缓冲区代理缓冲用户端请求的最大字节数（请求多）</p>\n<p>proxy_connect_timeout 5s; #nginx跟后端服务器连接超时时间（代理连接超时）</p>\n<p>proxy_read_timeout 60s; #连接成功后，后端服务器响应时间(代理接收超时)</p>\n<p>proxy_send_timeout 5s; #后端服务器数据回传时间(代理发送超时)</p>\n<p>proxy_buffer_size 16k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小</p>\n<p>proxy_buffers 4 64k; #该指令设置缓冲区的大小和数量,从被代理的后端服务器取得的响应内容,会放置到这里</p>\n<p>proxy_busy_buffers_size 128k; #所有处在busy状态的buffer size加起来不能超过proxy_busy_buffers_size</p>\n<p>proxy_temp_file_write_size 128k; #如果response的内容很大的话，Nginx会接收并把他们写入到temp_file里去。busy的buffer传输完了会从temp_file里面接着读数据，直到传输完毕</p>\n<p>gzip on; #NGINX可以压缩静态资源</p>\n<p>gzip_min_length 1k;</p>\n<p>gzip_buffers 4 16k;</p>\n<p>gzip_http_version 1.1;</p>\n<p>gzip_comp_level 2; #压缩级别大小，最小1，最大9，值越小，压缩后比例越小，CPU处理更快; 值越大压缩后占用带宽越少。</p>\n<p>gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型:text js css xml 都会被压缩</p>\n<p>gzip_vary on; #作用是在http响应中增加一行，目的是改变反向代理服务器的缓存策略</p>\n<p>log_format main '$remote_addr - $remote_user [$time_local] \"$request\" '</p>\n<p>'$status $body_bytes_sent \"$http_referer\" '</p>\n<p>'\"$http_user_agent\" \"$http_x_forwarded_for\"';</p>\n<p>access_log logs/access.log main;</p>\n<p>access_log off; #取消服务日志</p>\n<h2>日志格式</h2>\n<h3>ip 远程用户 当地时间 请求URL 状态 发送的大小 响应的头 客户端使用的浏览器 页面响应的时间</h3>\n<p>log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $request_time $http_x_forwarded_for'; #自定义格式</p>\n<p>access_log logs/access.log myFormat; #combined为日志格式的默认值</p>\n<p>sendfile on; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块</p>\n<p>sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限</p>\n<p>tcp_nopush on;</p>\n<p>tcp_nopush on; #防止网络阻塞</p>\n<p>keepalive_timeout 0;</p>\n<p>keepalive_timeout 65; #连接超时时间，默认为75s，可以在http，server，location块</p>\n<p>gzip on;</p>\n<h2>上游服务器</h2>\n<p>upstream mysvr {</p>\n<h3>负载均衡算法，默认为round-robin轮循</h3>\n<p>ip_hash; #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题,ip_hash不支持weight和backup</p>\n<p>server 192.168.5.91:7878 max_fails=2 fail_timeout=10s;</p>\n<p>server 192.168.5.92:7878 max_fails=2 fail_timeout=10s;</p>\n<p>server 192.168.5.91:7878 max_fails=2 fail_timeout=10s weight=1;</p>\n<p>server 192.168.5.92:7878 max_fails=2 fail_timeout=10s weight=2;</p>\n<p>server 192.168.5.90:7878 backup; #热备</p>\n<p>}</p>\n<h2>error_page 404 <a href=\"https://www.baidu.com\">https://www.baidu.com</a>; #错误页</h2>\n<p>server {</p>\n<p>keepalive_requests 120; #单连接请求上限次数</p>\n<p>listen 9080; #监听端口</p>\n<p>server_name localhost; #监听地址 127.0.0.1</p>\n<p>charset koi8-r;</p>\n<p>access_log logs/host.access.log main;</p>\n<p>location ~<em>^.+$ { #请求的url过滤，正则匹配，<del>为区分大小写，</del></em>为不区分大小写。</p>\n<p>root path; #根目录</p>\n<p>index vv.txt; #设置默认页</p>\n<h2>proxy_pass <a href=\"http://mysvr\">http://mysvr</a>; #请求转向mysvr 定义的服务器列表</h2>\n<p>deny 127.0.0.1; #拒绝的ip</p>\n<p>allow 172.18.5.54; #允许的ip</p>\n<p>}</p>\n<p>location /test {</p>\n<p>proxy_next_upstream http_502 http_504 error timeout invalid_header;</p>\n<p>proxy_next_upstream_timeout 10s;</p>\n<p>proxy_next_upstream_tries 2;</p>\n<p>proxy_set_header Host $host;</p>\n<p>proxy_set_header X-Real-IP $remote_addr;</p>\n<p>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</p>\n<p>add_header upstream_addr $upstream_addr;</p>\n<p>proxy_pass <a href=\"http://mysvr\">http://mysvr</a>;</p>\n<p>}</p>\n<h2>nginx主页</h2>\n<p>location / {</p>\n<p>root html;</p>\n<p>index index.html index.htm;</p>\n<p>}</p>\n<h2>用lua脚本向reids存值</h2>\n<p>location /lua/set {</p>\n<p>default_type 'text/plain';</p>\n<p>content_by_lua_file conf/lua/setKeyValue.lua;</p>\n<p>}</p>\n<h2>用lua脚本从reids取值</h2>\n<p>location /lua/get {</p>\n<p>default_type 'text/plain';</p>\n<p>content_by_lua_file conf/lua/getKey.lua;</p>\n<p>}</p>\n<h2>静态资源代理</h2>\n<p>location ~ .*.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ {</p>\n<p>root /var/local/static;</p>\n<p>expires 30d;</p>\n<p>}</p>\n<p>error_page 404 /404.html;</p>\n<p>redirect server error pages to the static page /50x.html</p>\n<h1></h1>\n<p>error_page 500 502 503 504 /50x.html;</p>\n<p>location = /50x.html {</p>\n<p>root html;</p>\n<p>}</p>\n<p>}</p>\n","date":"2012-08-13","title":"nginx配置项说明"},"prevPost":{"summary":null,"tags":["Linux"],"id":"linux-about-tech","title":"有关Linux的一些内容","date":"2013-03-01"},"nextPost":{"summary":null,"tags":["HTTP"],"id":"http-status-code","title":"常见HTTP状态码","date":"2012-05-09"}},"__N_SSG":true}